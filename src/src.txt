

--- FILE: ./controllers/author.controller.ts ---

import type { Request, Response } from "express";
import { successResponse } from "../utils/response";
import type { IAuthorService } from "../services/author.service";

export interface IAuthorController {
    list(req: Request, res: Response): Promise<void>;
    getById(req: Request, res: Response): Promise<void>;
    create(req: Request, res: Response): Promise<void>;
    update(req: Request, res: Response): Promise<void>;
    remove(req: Request, res: Response): Promise<void>;
    getStats(req: Request, res: Response): Promise<void>;
}

export class AuthorController implements IAuthorController {
    constructor(private authorService: IAuthorService) {
        this.list = this.list.bind(this);
        this.getById = this.getById.bind(this);
        this.create = this.create.bind(this);
        this.update = this.update.bind(this);
        this.remove = this.remove.bind(this);
        this.getStats = this.getStats.bind(this);
    }

    async list(req: Request, res: Response): Promise<void> {
        const page = Number(req.query.page) || 1;
        const limit = Number(req.query.limit) || 10;
        
        const search = {
            name: req.query.name as string
        };

        const sortBy = req.query.sortBy as string;
        const sortOrder = (req.query.sortOrder as 'asc' | 'desc') || 'desc';

        const result = await this.authorService.list({
            page,
            limit,
            search,
            sortBy,
            sortOrder
        });

        const pagination = {
            page: result.currentPage,
            limit,
            total: result.total,
            totalPages: result.totalPages
        };

        successResponse(
            res,
            "Daftar penulis berhasil diambil",
            result.authors,
            pagination
        );
    }

    async getById(req: Request, res: Response): Promise<void> {
        const { id } = req.params;
        if (!id) throw new Error("ID penulis diperlukan");

        const author = await this.authorService.getById(id);

        successResponse(
            res,
            "Detail penulis berhasil diambil",
            author
        );
    }

    async create(req: Request, res: Response): Promise<void> {
        const { name, bio, birthDate } = req.body;

        if (!name || !birthDate) {
            throw new Error("Nama dan tanggal lahir wajib diisi");
        }

        // Sesuai Prisma.AuthorCreateInput di skema kamu
        const author = await this.authorService.create({
            name: String(name),
            bio: bio ? String(bio) : null,
            birthDate: new Date(birthDate) // Pastikan dikonversi ke format Date
        });

        successResponse(
            res,
            "Penulis berhasil ditambahkan",
            author,
            null,
            201
        );
    }

    async update(req: Request, res: Response): Promise<void> {
        const { id } = req.params;
        if (!id) throw new Error("ID penulis diperlukan");

        // Jika ada birthDate di body, pastikan dikonversi ke Date object sebelum masuk service
        const updateData = { ...req.body };
        if (updateData.birthDate) {
            updateData.birthDate = new Date(updateData.birthDate);
        }

        const updatedAuthor = await this.authorService.update(id, updateData);

        successResponse(
            res,
            "Data penulis berhasil diperbarui",
            updatedAuthor
        );
    }

    async remove(req: Request, res: Response): Promise<void> {
        const { id } = req.params;
        if (!id) throw new Error("ID penulis diperlukan");

        const deletedAuthor = await this.authorService.delete(id);

        successResponse(
            res,
            "Penulis berhasil dihapus",
            deletedAuthor
        );
    }

    async getStats(_req: Request, res: Response): Promise<void> {
        const stats = await this.authorService.getTopAuthors();

        successResponse(
            res,
            "Statistik penulis berhasil diambil",
            stats
        );
    }
}

--- FILE: ./controllers/book.controller.ts ---

import type { Request, Response } from "express";
import { successResponse } from "../utils/response";
import type { IBookService } from "../services/book.service";

export interface IBookController {
    list(req: Request, res: Response): Promise<void>;
    getById(req: Request, res: Response): Promise<void>;
    create(req: Request, res: Response): Promise<void>;
    update(req: Request, res: Response): Promise<void>;
    remove(req: Request, res: Response): Promise<void>;
    getStats(req: Request, res: Response): Promise<void>;
}

export class BookController implements IBookController {
    constructor(private bookService: IBookService) {
        // Binding methods agar 'this' tetap merujuk pada class saat dipanggil router
        this.list = this.list.bind(this);
        this.getById = this.getById.bind(this);
        this.create = this.create.bind(this);
        this.update = this.update.bind(this);
        this.remove = this.remove.bind(this);
        this.getStats = this.getStats.bind(this);
    }

    async list(req: Request, res: Response) {
        const page = Number(req.query.page) || 1;
        const limit = Number(req.query.limit) || 10;
        
        // Parsing search params sesuai interface FindAllBooksParams
        const search = {
            title: req.query.title as string,
            authorId: req.query.authorId as string,
            categoryId: req.query.categoryId as string,
        };

        const sortBy = req.query.sortBy as string;
        const sortOrder = (req.query.sortOrder as 'asc' | 'desc') || 'desc';

        const result = await this.bookService.list({
            page,
            limit,
            search,
            sortBy,
            sortOrder
        });

        const pagination = {
            page: result.currentPage,
            limit,
            total: result.total,
            totalPages: result.totalPages
        };

        successResponse(
            res, 
            "Data buku berhasil diambil", 
            result.books, 
            pagination
        );
    }

    async getById(req: Request, res: Response) {
        const { id } = req.params;
        if (!id) {
            throw new Error("ID buku tidak ditemukan");
        }

        const book = await this.bookService.getById(id);

        successResponse(
            res, 
            "Detail buku berhasil diambil", 
            book
        );
    }

async create(req: Request, res: Response) {
    const file = req.file;
    if (!file) throw new Error("Cover image is required");

    const { title, isbn, year, stock, authorId, categoryId, description } = req.body;

    const imageUrl = `/public/uploads/${file.filename}`;

    const data = {
        title: String(title),
        isbn: String(isbn),
        year: Number(year),
        stock: Number(stock),
        authorId: String(authorId),
        categoryId: String(categoryId),
        coverImage: imageUrl,
        ...(description && { description: String(description) }),
    };

    const book = await this.bookService.create(data);

    successResponse(
        res,
        "Buku berhasil ditambahkan",
        book,
        null,
        201
    );
}

    async update(req: Request, res: Response) {
        const { id } = req.params;
        if (!id) throw new Error("ID buku diperlukan");

        const updatedBook = await this.bookService.update(id, req.body);

        successResponse(
            res,
            "Buku berhasil diperbarui",
            updatedBook
        );
    }

    async remove(req: Request, res: Response) {
        const { id } = req.params;
        if (!id) throw new Error("ID buku diperlukan");

        const deletedBook = await this.bookService.delete(id);

        successResponse(
            res,
            "Buku berhasil dihapus",
            deletedBook
        );
    }

    async getStats(_req: Request, res: Response) {
        const stats = await this.bookService.getDashboardStats();

        successResponse(
            res,
            "Statistik dashboard berhasil diambil",
            stats
        );
    }
}

--- FILE: ./controllers/category.controller.ts ---

import type { Request, Response } from "express";
import { successResponse } from "../utils/response";
import type { ICategoryService } from "../services/category.service";

export interface ICategoryController {
    list(req: Request, res: Response): Promise<void>;
    getById(req: Request, res: Response): Promise<void>;
    create(req: Request, res: Response): Promise<void>;
    update(req: Request, res: Response): Promise<void>;
    remove(req: Request, res: Response): Promise<void>;
    getStats(req: Request, res: Response): Promise<void>;
}

export class CategoryController implements ICategoryController {
    constructor(private categoryService: ICategoryService) { 
        this.list = this.list.bind(this);
        this.getById = this.getById.bind(this);
        this.create = this.create.bind(this);
        this.update = this.update.bind(this);
        this.remove = this.remove.bind(this);
        this.getStats = this.getStats.bind(this);
    }

    async list(req: Request, res: Response): Promise<void> {
        const page = Number(req.query.page) || 1;
        const limit = Number(req.query.limit) || 10;
        
        // Menyesuaikan dengan FindAllCategoriesParams di Service
        const search = {
            name: req.query.name as string
        };
        
        const sortBy = req.query.sortBy as string;
        const sortOrder = (req.query.sortOrder as 'asc' | 'desc') || 'desc';

        const result = await this.categoryService.list({
            page,
            limit,
            search,
            sortBy,
            sortOrder
        });

        const pagination = {
            page: result.currentPage,
            limit,
            total: result.total,
            totalPages: result.totalPages
        };

        successResponse(
            res,
            "Kategori berhasil diambil",
            result.categories,
            pagination
        );
    }

    async getById(req: Request, res: Response): Promise<void> {
        const { id } = req.params;
        if (!id) {
            throw new Error("Parameter id tidak ditemukan");
        }

        const category = await this.categoryService.getById(id);

        successResponse(
            res,
            "Kategori berhasil diambil",
            category
        );
    }

    async create(req: Request, res: Response): Promise<void> {
        const { name, description } = req.body;

        if (!name) {
            throw new Error("Nama kategori wajib diisi");
        }

        // Sesuai Prisma.CategoryCreateInput di skema kamu
        const category = await this.categoryService.create({
            name: String(name),
            description: String(description || "")
        });

        successResponse(
            res,
            "Kategori berhasil dibuat",
            category,
            null,
            201
        );
    }

    async update(req: Request, res: Response): Promise<void> {
        const { id } = req.params;
        if (!id) {
            throw new Error("Parameter id tidak ditemukan");
        }

        const category = await this.categoryService.update(id, req.body);

        successResponse(
            res,
            "Kategori berhasil diupdate",
            category
        );
    }

    async remove(req: Request, res: Response): Promise<void> {
        const { id } = req.params;
        if (!id) {
            throw new Error("Parameter id tidak ditemukan");
        }

        const deleted = await this.categoryService.delete(id);

        successResponse(
            res,
            "Kategori berhasil dihapus",
            deleted
        );
    }

    async getStats(_req: Request, res: Response): Promise<void> {
        const stats = await this.categoryService.getStats();

        successResponse(
            res,
            "Statistik kategori berhasil diambil",
            stats
        );
    }
}

--- FILE: ./controllers/member.controller.ts ---

import type { Request, Response } from "express";
import { successResponse } from "../utils/response";
import type { IMemberService } from "../services/member.service";

export interface IMemberController {
    list(req: Request, res: Response): Promise<void>;
    getById(req: Request, res: Response): Promise<void>;
    getByUserId(req: Request, res: Response): Promise<void>;
    create(req: Request, res: Response): Promise<void>;
    update(req: Request, res: Response): Promise<void>;
    remove(req: Request, res: Response): Promise<void>;
    getStats(req: Request, res: Response): Promise<void>;
}

export class MemberController implements IMemberController {
    constructor(private memberService: IMemberService) {
        this.list = this.list.bind(this);
        this.getById = this.getById.bind(this);
        this.getByUserId = this.getByUserId.bind(this);
        this.create = this.create.bind(this);
        this.update = this.update.bind(this);
        this.remove = this.remove.bind(this);
        this.getStats = this.getStats.bind(this);
    }

    async list(req: Request, res: Response) {
        const page = Number(req.query.page) || 1;
        const limit = Number(req.query.limit) || 10;
        const searchNama = req.query.nama as string | undefined;
        const searchEmail = req.query.email as string | undefined;
        const searchStatus = req.query.status as any;
        const sortBy = req.query.sortBy as string;
        const sortOrder = (req.query.sortOrder as 'asc' | 'desc') || 'desc';

        const result = await this.memberService.list({
            page,
            limit,
            search: {
                ...(searchNama && { nama: searchNama }),
                ...(searchEmail && { email: searchEmail }),
                ...(searchStatus && { status: searchStatus })
            },
            sortBy,
            sortOrder
        });

        const pagination = {
            page: result.currentPage,
            limit,
            total: result.total,
            totalPages: result.totalPages
        };

        successResponse(res, "Daftar member berhasil diambil", result.members, pagination);
    }

    async getById(req: Request, res: Response) {
        if (!req.params.id) throw new Error("ID member diperlukan");

        const member = await this.memberService.getById(req.params.id);
        successResponse(res, "Data member berhasil diambil", member);
    }

    async getByUserId(req: Request, res: Response) {
        const userId = req.params.userId;
        if (!userId) throw new Error("User ID tidak valid");

        // Catatan: Pastikan di member.repository kamu ada method findByUserId
        const member = await this.memberService.getById(userId); 
        successResponse(res, "Profil member berdasarkan user berhasil diambil", member);
    }

    async create(req: Request, res: Response) {
        const { kodeMember, nama, email, telepon, alamat, userId } = req.body;

        if (!kodeMember || !nama || !email) throw new Error("Data wajib diisi (Kode, Nama, Email)");

        const createData: any = {
            kodeMember: String(kodeMember),
            nama: String(nama),
            email: String(email),
            telepon: String(telepon),
            alamat: alamat ? String(alamat) : null,
        };

        // Jika ada relasi userId (UUID String)
        if (userId) {
            createData.user = { connect: { id: String(userId) } };
        }

        const member = await this.memberService.create(createData);
        successResponse(res, "Member berhasil dibuat", member, null, 201);
    }

    async update(req: Request, res: Response) {
        const { id } = req.params;
        if (!id) throw new Error("ID member diperlukan");

        const updateData = { ...req.body };

        const member = await this.memberService.update(id, updateData);
        successResponse(res, "Member berhasil diperbarui", member);
    }

    async remove(req: Request, res: Response) {
        if (!req.params.id) throw new Error("ID member diperlukan");
        
        const deleted = await this.memberService.delete(req.params.id);
        successResponse(res, "Member berhasil dihapus/dinonaktifkan", deleted);
    }

    async getStats(_req: Request, res: Response) {
        const stats = await this.memberService.getStats();
        successResponse(res, "Statistik member berhasil diambil", stats);
    }
}

--- FILE: ./controllers/transaction.controller.ts ---

    import type { Request, Response } from "express";
    import { successResponse } from "../utils/response";
    import type { ITransactionService } from "../services/transaction.service";

    export interface ITransactionController {
        list(req: Request, res: Response): Promise<void>;
        getById(req: Request, res: Response): Promise<void>;
        create(req: Request, res: Response): Promise<void>;
        returnBooks(req: Request, res: Response): Promise<void>;
        getStats(req: Request, res: Response): Promise<void>;
    }

    export class TransactionController implements ITransactionController {
        constructor(private transactionService: ITransactionService) {
            this.list = this.list.bind(this);
            this.getById = this.getById.bind(this);
            this.create = this.create.bind(this);
            this.returnBooks = this.returnBooks.bind(this);
            this.getStats = this.getStats.bind(this);
        }

        async list(req: Request, res: Response) {
            const page = Number(req.query.page) || 1;
            const limit = Number(req.query.limit) || 10;
            const sortBy = req.query.sortBy as string;
            const sortOrder = (req.query.sortOrder as 'asc' | 'desc') || 'desc';
            
            const memberId = req.query.memberId as string;
            const status = req.query.status as any;

            const result = await this.transactionService.list({
                page,
                limit,
                memberId,
                status,
                sortBy,
                sortOrder
            });

            const pagination = {
                page: result.currentPage,
                limit,
                total: result.total,
                totalPages: result.totalPages
            };

            successResponse(
                res,
                "Daftar transaksi berhasil diambil",
                result.transactions,
                pagination
            );
        }

        async getById(req: Request, res: Response) {
            const { id } = req.params;
            if (!id) throw new Error("ID transaksi diperlukan");

            const transaction = await this.transactionService.getById(id);

            successResponse(
                res,
                "Detail transaksi berhasil diambil",
                transaction
            );
        }

        async create(req: Request, res: Response) {
            const { memberId, items, dueDate } = req.body;

            if (!memberId || !items || !Array.isArray(items) || !dueDate) {
                throw new Error("Data memberId, items, dan dueDate wajib diisi");
            }

            const transaction = await this.transactionService.create({
                memberId: String(memberId),
                dueDate: new Date(dueDate),
                items: items.map((item: any) => ({
                    bookId: String(item.bookId),
                    quantity: Number(item.quantity)
                }))
            });

            successResponse(
                res,
                "Peminjaman buku berhasil dicatat",
                transaction,
                null,
                201
            );
        }

        /**
         * Fitur khusus Library: Pengembalian Buku
         */
        async returnBooks(req: Request, res: Response) {
            const { id } = req.params;
            if (!id) throw new Error("ID transaksi diperlukan untuk pengembalian");

            const result = await this.transactionService.returnBooks(id);

            successResponse(
                res,
                "Buku berhasil dikembalikan",
                result
            );
        }

        async getStats(_req: Request, res: Response) {
            const stats = await this.transactionService.exec();

            successResponse(
                res,
                "Statistik transaksi berhasil diambil",
                stats
            );
        }
    }

--- FILE: ./controllers/user.controller.ts ---

import type { Request, Response } from "express";
import { successResponse } from "../utils/response";
import type { IAuthService } from "../services/user.service";

export interface IAuthController {
    register(req: Request, res: Response): Promise<void>;
    login(req: Request, res: Response): Promise<void>;
    me(req: Request, res: Response): Promise<void>;
}

export class AuthController implements IAuthController {
    constructor(private authService: IAuthService) {
        // Binding methods SAMA dengan product API
        this.register = this.register.bind(this);
        this.login = this.login.bind(this);
        this.me = this.me.bind(this);
    }

    async register(req: Request, res: Response) {
        const { username, name, email, password, role } = req.body;

        // Validasi input minimal
        if (!username || !name || !email || !password) {
            throw new Error("Username, Nama, Email, dan Password wajib diisi");
        }

        const user = await this.authService.register({
            username: String(username),
            name: String(name),
            email: String(email),
            password: String(password),
            role: role ? String(role) : "MEMBER"  // Default MEMBER untuk library
        });

        successResponse(
            res, 
            "Registrasi berhasil", 
            user, 
            null, 
            201
        );
    }

    async login(req: Request, res: Response) {
        const { email, password } = req.body;

        if (!email || !password) {
            throw new Error("Email dan password wajib diisi");
        }

        const result = await this.authService.login(
            String(email), 
            String(password)
        );

        successResponse(
            res, 
            "Login berhasil", 
            result
        );
    }

    async me(req: Request, res: Response) {
        // Mengikuti pola product API: (req as any).user?.id
        const userId = (req as any).user?.id;

        if (!userId) {
            throw new Error("Unauthorized: Sesi tidak ditemukan");
        }

        const user = await this.authService.me(String(userId));

        successResponse(
            res, 
            "Data profil user berhasil diambil", 
            user
        );
    }
}

--- FILE: ./index.ts ---

import 'dotenv/config'  

import app from "./app";
import config from './utils/env';

app.listen(config.PORT, () => {
    console.log(`Server running at ${config.HOST}:${config.PORT}`);
});

--- FILE: ./middlewares/error.handler.ts ---

import type { NextFunction, Request, Response } from "express";
import { errorResponse } from "../utils/response";
import { Prisma } from "../generated/client";

export const errorHandler = (err: Error, _req: Request, res: Response, _next: NextFunction) => {
    console.error('ERROR:', err.message);

    const statusCode = err.message.includes('tidak ditemukan') ? 404 : 400;

    if (err instanceof Prisma.PrismaClientKnownRequestError) {
        if (err.code === 'P2002') {
            errorResponse(
                res,
                `Data sudah ada (Unique constraint violation) \n${err.message}`,
                statusCode,
                process.env.NODE_ENV === 'development' ? { stack: err.stack } as { stack?: string } : null 
            )
        }

        if (err.code === 'P2025') {
            errorResponse(
                res,
                `Data tidak ditemukan \n${err.message}`,
                statusCode,
                process.env.NODE_ENV === 'development' ? { stack: err.stack } as { stack: string } : null
            )
        }
    }

    errorResponse(
        res,
        err.message || 'Terjadi kesalahan server',
        statusCode,
        process.env.NODE_ENV === 'development' ? { stack: err.stack } as { stack?: string } : null
    )
};

--- FILE: ./middlewares/upload.middleware.ts ---

import multer from 'multer';
import path from 'path';
import type { Request } from 'express';

// Konfigurasi penyimpanan
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, 'public/uploads/');
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

// Filter tipe file
const fileFilter = (_req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedMimeTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
  
  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Hanya file gambar yang diperbolehkan (JPEG, JPG, PNG, GIF, WebP)'));
  }
};

// Middleware upload
export const upload = multer({ 
  storage: storage,
  limits: { 
    fileSize: 2 * 1024 * 1024 // Max 2MB
  },
  fileFilter: fileFilter
});

--- FILE: ./middlewares/auth.middleware.ts ---

import type { Request, Response, NextFunction } from 'express'
import jwt from 'jsonwebtoken'
import { errorResponse } from '../utils/response'
import config from "../utils/env"

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers.authorization

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return errorResponse(res, "Token tidak ditemukan", 401)
    }

    const token = authHeader.split(" ")[1]

    try {
        const payload = jwt.verify(token!, config.JWT_SECRET) as { 
            id: string; 
            role: string; 
            name?: string 
        };

        req.user = {
            id: String(payload.id),
            role: payload.role
        };

        next();
    } catch (error) {
        console.error("JWT Error:", error);
        return errorResponse(res, "Token tidak valid atau sudah kedaluwarsa", 401);
    }
}

--- FILE: ./middlewares/auth.validation.ts ---

import { body } from "express-validator";

export const registerValidation = [
  body("username")
    .trim()
    .notEmpty().withMessage("Username wajib diisi")
    .isLength({ min: 3 }).withMessage("Username minimal 3 karakter")
    .matches(/^[a-zA-Z0-9_]+$/).withMessage("Username hanya boleh berisi huruf, angka, dan underscore"),

  body("email")
    .trim()
    .notEmpty().withMessage("Email wajib diisi")
    .isEmail().withMessage("Format email tidak valid")
    .normalizeEmail(),

  body("password")
    .notEmpty().withMessage("Password wajib diisi")
    .isLength({ min: 6 }).withMessage("Password minimal 6 karakter"),

  body("name")
    .trim()
    .notEmpty().withMessage("Nama lengkap wajib diisi")
    .isLength({ min: 3 }).withMessage("Nama minimal 3 karakter"),

  body("role")
    .optional()
    .isIn(["ADMIN", "LIBRARIAN", "MEMBER"]).withMessage("Role harus ADMIN, LIBRARIAN, atau MEMBER")
];

export const loginValidation = [
  body("username")
    .trim()
    .notEmpty().withMessage("Username wajib diisi"),

  body("password")
    .notEmpty().withMessage("Password wajib diisi")
];

--- FILE: ./middlewares/author.validation.ts ---

import { body, param, query } from "express-validator";

export const createAuthorValidation = [
    body('name')
        .trim()
        .notEmpty().withMessage('Nama penulis wajib diisi')
        .isLength({ min: 3 }).withMessage('Nama penulis minimal 3 karakter'),

    body('birthDate')
        .notEmpty().withMessage('Tanggal lahir wajib diisi')
        .isISO8601().withMessage('Format tanggal harus YYYY-MM-DD')
        .custom(value => {
            const date = new Date(value);
            return date < new Date();
        }).withMessage('Tanggal lahir tidak boleh di masa depan')
];

export const updateAuthorValidation = [
    param('id')
        .isUUID().withMessage('ID harus UUID valid'),

    body('name')
        .optional()
        .trim()
        .isLength({ min: 3 }).withMessage('Nama penulis minimal 3 karakter'),

    body('birthDate')
        .optional()
        .isISO8601().withMessage('Format tanggal harus YYYY-MM-DD')
        .custom(value => {
            const date = new Date(value);
            return date < new Date();
        }).withMessage('Tanggal lahir tidak boleh di masa depan')
];

export const getAuthorByIdValidation = [
    param('id')
        .isUUID().withMessage('ID harus UUID valid')
];

export const searchAuthorValidation = [
    query('name')
        .optional()
        .trim()
        .isLength({ min: 1 }).withMessage('Nama pencarian minimal 1 karakter')
];

--- FILE: ./middlewares/book.validation.ts ---

import { body, param, query } from "express-validator";

export const createBookValidation = [
    body('title')
        .trim()
        .notEmpty().withMessage('Judul buku wajib diisi')
        .isLength({ min: 3 }).withMessage('Judul buku minimal 3 karakter'),

    body('isbn')
        .trim()
        .notEmpty().withMessage('ISBN wajib diisi')
        .isLength({ min: 10, max: 13 }).withMessage('ISBN harus 10-13 karakter'),

    body('year')
        .isInt({ min: 1000, max: new Date().getFullYear() })
        .withMessage('Tahun terbit harus valid'),

    body('stock')
        .isInt({ min: 0 }).withMessage('Stok tidak boleh negatif'),

    body('authorId')
        .trim()
        .notEmpty().withMessage('ID penulis wajib diisi')
        .isUUID().withMessage('ID penulis harus UUID valid')
];

export const updateBookValidation = [
    param('id')
        .isUUID().withMessage('ID harus UUID valid'),

    body('isbn')
        .optional()
        .trim()
        .isLength({ min: 10, max: 13 }).withMessage('ISBN harus 10-13 karakter'),

    body('year')
        .optional()
        .isInt({ min: 1000, max: new Date().getFullYear() })
        .withMessage('Tahun terbit harus valid'),

    body('stock')
        .optional()
        .isInt({ min: 0 }).withMessage('Stok tidak boleh negatif')
];

export const getBookByIdValidation = [
    param('id')
        .isUUID().withMessage('ID harus UUID valid')
];

export const searchBookValidation = [
    query('title')
        .optional()
        .trim()
        .isLength({ min: 1 }).withMessage('Judul pencarian minimal 1 karakter'),

    query('author')
        .optional()
        .trim()
        .isLength({ min: 1 }).withMessage('Nama penulis pencarian minimal 1 karakter'),

    query('year')
        .optional()
        .isInt({ min: 1000, max: new Date().getFullYear() })
        .withMessage('Tahun harus valid')
];

--- FILE: ./middlewares/member.validation.ts ---

import type { NextFunction, Request, Response } from "express";
import { body, param, validationResult, type ValidationChain } from "express-validator";
import { errorResponse } from "../utils/response";

export const validate = (validations: ValidationChain[]) => {
    return async (req: Request, res: Response, next: NextFunction) => {
        await Promise.all(validations.map(validation => validation.run(req)))

        const errors = validationResult(req)
        if (errors.isEmpty()) {
            return next()
        }

        const errorList = errors.array().map(err => ({
            field: err.type === 'field' ? err.path : 'unknown',
            message: err.msg 
        }))

        return errorResponse(res, "Validasi tidak berhasil", 400, errorList)
    }
}

export const createMemberValidation = [
    body('nama')
        .trim()
        .notEmpty().withMessage('Nama harus diisi')
        .isLength({ min: 3 }).withMessage('Nama minimal 3 karakter'),

    body('email')
        .trim()
        .notEmpty().withMessage('Email wajib diisi')
        .isEmail().withMessage('Format email tidak valid'),

    body('telepon')
        .trim()
        .notEmpty().withMessage('Telepon wajib diisi')
        .matches(/^[0-9]+$/).withMessage('Telepon harus angka')
        .isLength({ min: 10, max: 13 }).withMessage('Telepon harus 10-13 digit'),

    body('tanggal_daftar')
        .optional()
        .isDate().withMessage('Format tanggal tidak valid (YYYY-MM-DD)')
]

export const getMemberByIdValidation = [
    param('id')
        .isNumeric().withMessage('Id harus angka')
        .custom(value => parseInt(value) > 0).withMessage('Id harus lebih dari 0')
]

--- FILE: ./middlewares/transaction.validation.ts ---

import { body, param, query } from "express-validator";

export const borrowValidation = [
  body('memberId')
    .trim()
    .notEmpty().withMessage('ID anggota wajib diisi')
    .isLength({ min: 1 }).withMessage('ID anggota minimal 1 karakter'),

  body('books')
    .isArray({ min: 1 }).withMessage('Daftar buku wajib diisi minimal 1 buku')
    .custom((books: any[]) => {
      if (!Array.isArray(books)) {
        throw new Error('Books harus berupa array');
      }
      
      for (const book of books) {
        if (!book.bookId) {
          throw new Error('Setiap buku harus memiliki bookId');
        }
        if (!book.quantity || book.quantity < 1) {
          throw new Error('Quantity harus minimal 1');
        }
      }
      return true;
    }),

  body('dueDate')
    .notEmpty().withMessage('Tanggal jatuh tempo wajib diisi')
    .isISO8601().withMessage('Format tanggal harus YYYY-MM-DD')
    .custom(value => {
      const dueDate = new Date(value);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      if (dueDate <= today) {
        throw new Error('Tanggal jatuh tempo harus di masa depan');
      }
      return true;
    })
];

export const returnValidation = [
  param('id')
    .trim()
    .notEmpty().withMessage('ID transaksi wajib diisi')
    .isUUID().withMessage('ID transaksi harus UUID valid')
];

export const getByIdValidation = [
  param('id')
    .trim()
    .notEmpty().withMessage('ID transaksi wajib diisi')
    .isUUID().withMessage('ID transaksi harus UUID valid')
];

export const getAllValidation = [
  query('page')
    .optional()
    .isInt({ min: 1 }).withMessage('Page harus angka positif'),
  
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 }).withMessage('Limit harus antara 1-100'),
  
  query('memberId')
    .optional()
    .trim()
    .isLength({ min: 1 }).withMessage('Member ID minimal 1 karakter'),
  
  query('status')
    .optional()
    .isIn(['BORROWED', 'RETURNED', 'OVERDUE', 'CANCELLED'])
    .withMessage('Status harus salah satu dari: BORROWED, RETURNED, OVERDUE, CANCELLED')
];

--- FILE: ./models/book.model.ts ---

export interface Book {
    id: number
    judul: string
    penulis: string
    tahun: number
    stok: number
    deskripsi?: string
    created_at?: string
    updated_at?: string
}

export let books: Book[] = [
    { id: 1, judul: "Laskar Pelangi", penulis: "Andrea Hirata", tahun: 2005, stok: 10, deskripsi: "Novel tentang persahabatan dan pendidikan", created_at: "2024-01-01T00:00:00Z" },
    { id: 2, judul: "Bumi Manusia", penulis: "Pramoedya Ananta Toer", tahun: 1980, stok: 5, deskripsi: "Novel sejarah Indonesia", created_at: "2024-01-02T00:00:00Z" },
    { id: 3, judul: "Harry Potter and the Sorcerer's Stone", penulis: "J.K. Rowling", tahun: 1997, stok: 15, deskripsi: "Fantasi tentang penyihir muda", created_at: "2024-01-03T00:00:00Z" },
    { id: 4, judul: "The Hobbit", penulis: "J.R.R. Tolkien", tahun: 1937, stok: 8, deskripsi: "Petualangan Bilbo Baggins", created_at: "2024-01-04T00:00:00Z" },
    { id: 5, judul: "Dilan 1990", penulis: "Pidi Baiq", tahun: 2014, stok: 20, deskripsi: "Romance masa SMA", created_at: "2024-01-05T00:00:00Z" },
]



--- FILE: ./models/member.model.ts ---

export interface Member {
    id: number
    nama: string
    email: string
    telepon: string
    alamat?: string
    tanggal_daftar: string
    created_at?: string
    updated_at?: string
}

export let members: Member[] = [
    { id: 1, nama: "Muhammad Harits", email: "wert640559@gmail.com", telepon: "083132212944", alamat: "Jl. M. Ali No. 30", tanggal_daftar: "2025-12-06", created_at: "2025-12-06T00:00:00Z" },
    { id: 2, nama: "Iqbal Jalaluddin", email: "iqbal@email.com", telepon: "085183071309", alamat: "Jl. Sudirman No. 2", tanggal_daftar: "2025-12-06", created_at: "2025-12-06T00:00:00Z" },
    { id: 3, nama: "Agus Wijaya", email: "agus@email.com", telepon: "08345678901", alamat: "Jl. Thamrin No. 3", tanggal_daftar: "2024-01-03", created_at: "2024-01-03T00:00:00Z" },
    { id: 4, nama: "Maya Sari", email: "maya@email.com", telepon: "08456789012", alamat: "Jl. Gatot Subroto No. 4", tanggal_daftar: "2024-01-04", created_at: "2024-01-04T00:00:00Z" },
    { id: 5, nama: "Rudi Hartono", email: "rudi@email.com", telepon: "08567890123", alamat: "Jl. Diponegoro No. 5", tanggal_daftar: "2024-01-05", created_at: "2024-01-05T00:00:00Z" },
] 


--- FILE: ./routes/transaction.route.ts ---

import { Router } from "express";
import { 
    borrowValidation, 
    returnValidation, 
    getByIdValidation, 
    getAllValidation 
} from "../middlewares/transaction.validation";
import { TransactionController } from "../controllers/transaction.controller";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import { TransactionRepository } from "../repositories/transaction.repository";
import { BookRepository } from "../repositories/book.repository";
import prismaInstance from "../prisma";
import { TransactionService } from "../services/transaction.service";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Transactions
 *   description: Manajemen peminjaman dan pengembalian buku
 */

/**
 * @swagger
 * /transactions:
 *   get:
 *     summary: Mendapatkan daftar transaksi dengan filter
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *         description: Nomor halaman
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *           default: 10
 *         description: Jumlah data per halaman
 *       - in: query
 *         name: memberId
 *         schema:
 *           type: string
 *           format: uuid
 *         description: Filter berdasarkan ID member
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [BORROWED, RETURNED, OVERDUE, CANCELLED]
 *         description: Filter berdasarkan status transaksi
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *           enum: [createdAt, dueDate, returnDate]
 *           default: createdAt
 *         description: Field untuk sorting
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *           default: desc
 *         description: Urutan sorting
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar transaksi
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Transaction'
 *                 pagination:
 *                   $ref: '#/components/schemas/Pagination'
 *       401:
 *         description: Tidak terautentikasi
 *       400:
 *         description: Parameter query tidak valid
 */

/**
 * @swagger
 * /transactions/stats:
 *   get:
 *     summary: Mendapatkan statistik transaksi
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     overview:
 *                       type: object
 *                       properties:
 *                         totalTransactions:
 *                           type: integer
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /transactions:
 *   post:
 *     summary: Membuat peminjaman buku baru
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberId
 *               - items
 *               - dueDate
 *             properties:
 *               memberId:
 *                 type: string
 *                 format: uuid
 *                 example: "123e4567-e89b-12d3-a456-426614174000"
 *               dueDate:
 *                 type: string
 *                 format: date
 *                 example: "2025-12-31"
 *                 description: Tanggal jatuh tempo pengembalian
 *               items:
 *                 type: array
 *                 minItems: 1
 *                 items:
 *                   type: object
 *                   required:
 *                     - bookId
 *                     - quantity
 *                   properties:
 *                     bookId:
 *                       type: string
 *                       format: uuid
 *                       example: "456e4567-e89b-12d3-a456-426614174000"
 *                     quantity:
 *                       type: integer
 *                       minimum: 1
 *                       example: 1
 *     responses:
 *       201:
 *         description: Peminjaman berhasil dicatat
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/TransactionDetail'
 *       400:
 *         description: Validasi gagal, stok tidak cukup, atau member tidak valid
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /transactions/{id}:
 *   get:
 *     summary: Detail transaksi berdasarkan ID
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Data ditemukan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/TransactionDetail'
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Transaksi tidak ditemukan
 */

/**
 * @swagger
 * /transactions/return/{id}:
 *   patch:
 *     summary: Proses pengembalian buku
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Buku berhasil dikembalikan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Transaction'
 *       400:
 *         description: Transaksi sudah dikembalikan atau ID tidak valid
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Transaksi tidak ditemukan
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     Transaction:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           format: uuid
 *         memberId:
 *           type: string
 *           format: uuid
 *         status:
 *           type: string
 *           enum: [BORROWED, RETURNED, OVERDUE, CANCELLED]
 *         dueDate:
 *           type: string
 *           format: date-time
 *         returnDate:
 *           type: string
 *           format: date-time
 *           nullable: true
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 *         member:
 *           $ref: '#/components/schemas/Member'
 *     TransactionDetail:
 *       allOf:
 *         - $ref: '#/components/schemas/Transaction'
 *         - type: object
 *           properties:
 *             items:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: string
 *                     format: uuid
 *                   bookId:
 *                     type: string
 *                     format: uuid
 *                   quantity:
 *                     type: integer
 *                   book:
 *                     $ref: '#/components/schemas/Book'
 */

// --- Inisialisasi Layer ---
const transactionRepo = new TransactionRepository(prismaInstance);
const bookRepo = new BookRepository(prismaInstance);
const service = new TransactionService(transactionRepo, bookRepo);
const controller = new TransactionController(service);

// --- Route Definitions ---
router.get('/', authenticate, validate(getAllValidation), controller.list);
router.get('/stats', authenticate, controller.getStats);
router.get('/:id', authenticate, validate(getByIdValidation), controller.getById);
router.post('/', authenticate, validate(borrowValidation), controller.create);
router.patch('/return/:id', authenticate, validate(returnValidation), controller.returnBooks);

export default router;

--- FILE: ./routes/auth.route.ts ---

import { Router } from "express";
import { AuthController } from "../controllers/user.controller";
import { AuthService } from "../services/user.service";
import { UserRepository } from "../repositories/user.repository";
import { loginValidation, registerValidation } from "../middlewares/auth.validation";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Auth
 *   description: Operasi autentikasi pengguna
 */

/**
 * @swagger
 * /auth/register:
 *   post:
 *     summary: Registrasi pengguna baru
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - username
 *               - email
 *               - password
 *               - name
 *             properties:
 *               username:
 *                 type: string
 *                 minLength: 3
 *                 example: harits
 *               email:
 *                 type: string
 *                 format: email
 *                 example: harits@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 minLength: 6
 *                 example: rahasia123
 *               name:
 *                 type: string
 *                 minLength: 3
 *                 example: Muhammad Harits
 *               role:
 *                 type: string
 *                 enum: [ADMIN, LIBRARIAN, MEMBER]
 *                 default: MEMBER
 *                 example: MEMBER
 *     responses:
 *       201:
 *         description: Berhasil registrasi
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Registrasi berhasil
 *                 data:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                       format: uuid
 *                     username:
 *                       type: string
 *                     email:
 *                       type: string
 *                     name:
 *                       type: string
 *                     role:
 *                       type: string
 *       400:
 *         description: Validasi gagal atau data sudah terdaftar
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: Login untuk mendapatkan token JWT
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - username
 *               - email
 *               - password
 *             properties:
 *               username:
 *                 type: string
 *                 example: harits
 *               email:
 *                 type: string
 *                 format: email
 *                 example: harits@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 example: rahasia123
 *     responses:
 *       200:
 *         description: Login berhasil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Login berhasil
 *                 data:
 *                   type: object
 *                   properties:
 *                     user:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: string
 *                           format: uuid
 *                         username:
 *                           type: string
 *                         email:
 *                           type: string
 *                         name:
 *                           type: string
 *                         role:
 *                           type: string
 *                     token:
 *                       type: string
 *                       description: JWT token untuk autentikasi
 *       401:
 *         description: Email atau password salah
 *       400:
 *         description: Validasi gagal
 *       500:
 *         description: Server error
 */

/**
 * @swagger
 * /auth/me:
 *   get:
 *     summary: Mendapatkan profil user yang sedang login
 *     tags: [Auth]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Data profil berhasil diambil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 message:
 *                   type: string
 *                   example: Data profil user berhasil diambil
 *                 data:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                       format: uuid
 *                     username:
 *                       type: string
 *                     email:
 *                       type: string
 *                     name:
 *                       type: string
 *                     role:
 *                       type: string
 *                     createdAt:
 *                       type: string
 *                       format: date-time
 *                     updatedAt:
 *                       type: string
 *                       format: date-time
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: User tidak ditemukan
 *       500:
 *         description: Server error
 */

// Inisialisasi Layer
const repo = new UserRepository(prismaInstance);
const service = new AuthService(repo);
const controller = new AuthController(service);

// Endpoints
router.post("/register", validate(registerValidation), (req, res) => controller.register(req, res));
router.post("/login", validate(loginValidation), (req, res) => controller.login(req, res));
router.get("/me", authenticate, (req, res) => controller.me(req, res));

export default router;

--- FILE: ./routes/author.route.ts ---

import { Router } from "express";
import { AuthorController } from "../controllers/author.controller";
import { AuthorService } from "../services/author.service";
import { AuthorRepository } from "../repositories/author.repository";
import { 
    createAuthorValidation, 
    updateAuthorValidation, 
    getAuthorByIdValidation, 
    searchAuthorValidation 
} from "../middlewares/author.validation";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Authors
 *   description: Manajemen data penulis buku
 */

/**
 * @swagger
 * /authors:
 *   get:
 *     summary: Mendapatkan daftar penulis dengan pagination dan filter
 *     tags: [Authors]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *         description: Nomor halaman
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *           default: 10
 *         description: Jumlah data per halaman
 *       - in: query
 *         name: name
 *         schema:
 *           type: string
 *         description: Filter berdasarkan nama penulis (case-insensitive)
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *           enum: [name, birthDate, createdAt, updatedAt]
 *           default: createdAt
 *         description: Field untuk sorting
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *           default: desc
 *         description: Urutan sorting
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar penulis
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Author'
 *                 pagination:
 *                   type: object
 *                   properties:
 *                     page:
 *                       type: integer
 *                     limit:
 *                       type: integer
 *                     total:
 *                       type: integer
 *                     totalPages:
 *                       type: integer
 *       400:
 *         description: Parameter query tidak valid
 */

/**
 * @swagger
 * /authors/stats:
 *   get:
 *     summary: Mendapatkan statistik penulis terproduktif
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       name:
 *                         type: string
 *                       bookCount:
 *                         type: integer
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /authors:
 *   post:
 *     summary: Menambahkan penulis baru
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - birthDate
 *             properties:
 *               name:
 *                 type: string
 *                 minLength: 3
 *                 example: Andrea Hirata
 *               bio:
 *                 type: string
 *                 example: Penulis novel bestseller Laskar Pelangi
 *               birthDate:
 *                 type: string
 *                 format: date
 *                 example: "1967-10-24"
 *     responses:
 *       201:
 *         description: Penulis berhasil ditambahkan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Author'
 *       400:
 *         description: Validasi gagal atau nama sudah terdaftar
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /authors/{id}:
 *   get:
 *     summary: Detail penulis berdasarkan ID
 *     tags: [Authors]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *         description: UUID penulis
 *     responses:
 *       200:
 *         description: Data penulis ditemukan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/AuthorDetail'
 *       404:
 *         description: Penulis tidak ditemukan
 *       400:
 *         description: ID tidak valid
 */

/**
 * @swagger
 * /authors/{id}:
 *   put:
 *     summary: Update data penulis
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 minLength: 3
 *                 example: Andrea Hirata S.T.
 *               bio:
 *                 type: string
 *               birthDate:
 *                 type: string
 *                 format: date
 *                 example: "1967-10-24"
 *     responses:
 *       200:
 *         description: Update berhasil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Author'
 *       400:
 *         description: Validasi gagal atau nama sudah digunakan
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Penulis tidak ditemukan
 */

/**
 * @swagger
 * /authors/{id}:
 *   delete:
 *     summary: Hapus data penulis
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Penulis berhasil dihapus
 *       400:
 *         description: Gagal karena penulis masih memiliki buku aktif
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Penulis tidak ditemukan
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     Author:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           format: uuid
 *         name:
 *           type: string
 *         bio:
 *           type: string
 *           nullable: true
 *         birthDate:
 *           type: string
 *           format: date
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 *         _count:
 *           type: object
 *           properties:
 *             books:
 *               type: integer
 *     AuthorDetail:
 *       allOf:
 *         - $ref: '#/components/schemas/Author'
 *         - type: object
 *           properties:
 *             books:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: string
 *                     format: uuid
 *                   title:
 *                     type: string
 *                   isbn:
 *                     type: string
 */

// --- Inisialisasi Layer (Dependency Injection) ---
const repo = new AuthorRepository(prismaInstance);
const service = new AuthorService(repo);
const controller = new AuthorController(service);

// --- ROUTE URUTAN PENTING: STATS DULU, BARU :id ---

// 1. Route stats HARUS SEBELUM route :id
router.get("/stats", authenticate, (req, res) => controller.getStats(req, res));

// 2. Collection routes (tanpa ID)
router.get("/", 
    validate(searchAuthorValidation), 
    (req, res) => controller.list(req, res)
);

router.post("/", 
    authenticate, 
    validate(createAuthorValidation), 
    (req, res) => controller.create(req, res)
);

// 3. Member routes (dengan ID) - HARUS DI BAWAH
router.get("/:id", 
    validate(getAuthorByIdValidation), 
    (req, res) => controller.getById(req, res)
);

router.put("/:id", 
    authenticate, 
    validate(updateAuthorValidation), 
    (req, res) => controller.update(req, res)
);

router.delete("/:id", 
    authenticate, 
    validate(getAuthorByIdValidation), 
    (req, res) => controller.remove(req, res)
);

export default router;

--- FILE: ./routes/book.route.ts ---

import { Router } from "express";
import { BookController } from "../controllers/book.controller";
import { BookService } from "../services/book.service";
import { BookRepository } from "../repositories/book.repository";
import { 
    createBookValidation, 
    updateBookValidation, 
    getBookByIdValidation, 
    searchBookValidation 
} from "../middlewares/book.validation";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import { upload } from "../middlewares/upload.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Books
 *   description: Manajemen data buku dan koleksi perpustakaan
 */

/**
 * @swagger
 * /books:
 *   get:
 *     summary: Mendapatkan daftar buku dengan pagination dan filter
 *     tags: [Books]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *         description: Nomor halaman
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *           default: 10
 *         description: Jumlah data per halaman
 *       - in: query
 *         name: title
 *         schema:
 *           type: string
 *         description: Filter berdasarkan judul buku
 *       - in: query
 *         name: authorId
 *         schema:
 *           type: string
 *           format: uuid
 *         description: Filter berdasarkan ID penulis
 *       - in: query
 *         name: categoryId
 *         schema:
 *           type: string
 *           format: uuid
 *         description: Filter berdasarkan ID kategori
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *           enum: [title, year, stock, createdAt, updatedAt]
 *           default: createdAt
 *         description: Field untuk sorting
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *           default: desc
 *         description: Urutan sorting
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar buku
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Book'
 *                 pagination:
 *                   $ref: '#/components/schemas/Pagination'
 *       400:
 *         description: Parameter query tidak valid
 */

/**
 * @swagger
 * /books/stats:
 *   get:
 *     summary: Mendapatkan statistik dashboard buku
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     totalAvailableBooks:
 *                       type: integer
 *                       description: Total stok buku yang tersedia
 *                     activeTransactions:
 *                       type: integer
 *                       description: Jumlah transaksi peminjaman aktif
 *                     popularBook:
 *                       type: string
 *                       description: Judul buku paling populer
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /books:
 *   post:
 *     summary: Membuat buku baru dengan upload cover
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - isbn
 *               - year
 *               - stock
 *               - authorId
 *               - categoryId
 *               - coverImage
 *             properties:
 *               title:
 *                 type: string
 *                 minLength: 3
 *                 example: Laskar Pelangi
 *               isbn:
 *                 type: string
 *                 minLength: 10
 *                 maxLength: 13
 *                 example: "9789793062792"
 *               year:
 *                 type: integer
 *                 minimum: 1000
 *                 maximum: 2025
 *                 example: 2005
 *               stock:
 *                 type: integer
 *                 minimum: 0
 *                 example: 10
 *               authorId:
 *                 type: string
 *                 format: uuid
 *                 example: "123e4567-e89b-12d3-a456-426614174000"
 *               categoryId:
 *                 type: string
 *                 format: uuid
 *                 example: "456e4567-e89b-12d3-a456-426614174000"
 *               description:
 *                 type: string
 *                 example: Novel tentang persahabatan dan pendidikan
 *               coverImage:
 *                 type: string
 *                 format: binary
 *                 description: File gambar cover (JPEG, PNG, max 2MB)
 *     responses:
 *       201:
 *         description: Buku berhasil ditambahkan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Book'
 *       400:
 *         description: Validasi gagal atau data tidak lengkap
 *       401:
 *         description: Tidak terautentikasi
 *       413:
 *         description: File terlalu besar
 */

/**
 * @swagger
 * /books/{id}:
 *   get:
 *     summary: Detail buku berdasarkan ID
 *     tags: [Books]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Data buku ditemukan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/BookDetail'
 *       404:
 *         description: Buku tidak ditemukan
 *       400:
 *         description: ID tidak valid
 */

/**
 * @swagger
 * /books/{id}:
 *   put:
 *     summary: Update data buku
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 minLength: 3
 *               isbn:
 *                 type: string
 *                 minLength: 10
 *                 maxLength: 13
 *               year:
 *                 type: integer
 *                 minimum: 1000
 *                 maximum: 2025
 *               stock:
 *                 type: integer
 *                 minimum: 0
 *               description:
 *                 type: string
 *     responses:
 *       200:
 *         description: Update berhasil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Book'
 *       400:
 *         description: Validasi gagal
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Buku tidak ditemukan
 */

/**
 * @swagger
 * /books/{id}:
 *   delete:
 *     summary: Hapus buku (Soft Delete)
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Buku berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Book'
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Buku tidak ditemukan
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     Book:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           format: uuid
 *         title:
 *           type: string
 *         isbn:
 *           type: string
 *         year:
 *           type: integer
 *         stock:
 *           type: integer
 *         coverImage:
 *           type: string
 *           nullable: true
 *         description:
 *           type: string
 *           nullable: true
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 *         deletedAt:
 *           type: string
 *           format: date-time
 *           nullable: true
 *     BookDetail:
 *       allOf:
 *         - $ref: '#/components/schemas/Book'
 *         - type: object
 *           properties:
 *             author:
 *               $ref: '#/components/schemas/Author'
 *             category:
 *               $ref: '#/components/schemas/Category'
 *     Pagination:
 *       type: object
 *       properties:
 *         page:
 *           type: integer
 *         limit:
 *           type: integer
 *         total:
 *           type: integer
 *         totalPages:
 *           type: integer
 */

// --- Dependency Injection ---
const repo = new BookRepository(prismaInstance);
const service = new BookService(repo);
const controller = new BookController(service);

// --- Routes Definition ---

// 1. Stats diletakkan paling atas agar tidak bertabrakan dengan /:id
router.get("/stats", authenticate, controller.getStats);

// 2. Collection routes
router.get("/", validate(searchBookValidation), controller.list);
router.post(
    "/", 
    authenticate, 
    upload.single('coverImage'), 
    validate(createBookValidation), 
    controller.create
);

// 3. Member routes (menggunakan :id)
router.get("/:id", validate(getBookByIdValidation), controller.getById);
router.put("/:id", authenticate, validate(updateBookValidation), controller.update);
router.delete("/:id", authenticate, validate(getBookByIdValidation), controller.remove);

export default router;

--- FILE: ./routes/category.route.ts ---

import { Router } from "express";
import { CategoryController } from "../controllers/category.controller";
import { CategoryService } from "../services/category.service";
import { CategoryRepository } from "../repositories/category.repository";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Categories
 *   description: Manajemen kategori buku
 */

/**
 * @swagger
 * /categories:
 *   get:
 *     summary: Mendapatkan daftar kategori dengan pagination
 *     tags: [Categories]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *         description: Nomor halaman
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *           default: 10
 *         description: Jumlah data per halaman
 *       - in: query
 *         name: name
 *         schema:
 *           type: string
 *         description: Filter berdasarkan nama kategori
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *           enum: [name, createdAt, updatedAt]
 *           default: createdAt
 *         description: Field untuk sorting
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *           default: desc
 *         description: Urutan sorting
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar kategori
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Category'
 *                 pagination:
 *                   $ref: '#/components/schemas/Pagination'
 *       400:
 *         description: Parameter query tidak valid
 */

/**
 * @swagger
 * /categories/stats:
 *   get:
 *     summary: Mendapatkan statistik buku per kategori
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       categoryName:
 *                         type: string
 *                       totalBooks:
 *                         type: integer
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /categories:
 *   post:
 *     summary: Membuat kategori baru
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *             properties:
 *               name:
 *                 type: string
 *                 minLength: 3
 *                 example: Novel
 *               description:
 *                 type: string
 *                 example: Kumpulan karya fiksi naratif
 *     responses:
 *       201:
 *         description: Kategori berhasil dibuat
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Category'
 *       400:
 *         description: Validasi gagal atau nama sudah ada
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /categories/{id}:
 *   get:
 *     summary: Detail kategori berdasarkan ID
 *     tags: [Categories]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Data kategori ditemukan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/CategoryDetail'
 *       404:
 *         description: Kategori tidak ditemukan
 *       400:
 *         description: ID tidak valid
 */

/**
 * @swagger
 * /categories/{id}:
 *   put:
 *     summary: Update data kategori
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 minLength: 3
 *               description:
 *                 type: string
 *     responses:
 *       200:
 *         description: Update kategori berhasil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Category'
 *       400:
 *         description: Validasi gagal
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Kategori tidak ditemukan
 */

/**
 * @swagger
 * /categories/{id}:
 *   delete:
 *     summary: Hapus kategori
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Kategori berhasil dihapus
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Category'
 *       400:
 *         description: Gagal menghapus karena kategori masih memiliki buku aktif
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Kategori tidak ditemukan
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     Category:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           format: uuid
 *         name:
 *           type: string
 *         description:
 *           type: string
 *           nullable: true
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 *         _count:
 *           type: object
 *           properties:
 *             books:
 *               type: integer
 *     CategoryDetail:
 *       allOf:
 *         - $ref: '#/components/schemas/Category'
 *         - type: object
 *           properties:
 *             books:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Book'
 */

// --- Inisialisasi Layer (DI) ---
const repo = new CategoryRepository(prismaInstance);
const service = new CategoryService(repo);
const controller = new CategoryController(service);

// --- Route Definitions ---

// Route stats diletakkan sebelum :id
router.get("/stats", authenticate, controller.getStats);

router.get("/", controller.list);
router.post("/", authenticate, validate([]), controller.create);

router.get("/:id", controller.getById);
router.put("/:id", authenticate, validate([]), controller.update);
router.delete("/:id", authenticate, controller.remove);

export default router;

--- FILE: ./routes/member.route.ts ---

import { Router } from "express";
import { 
    createMemberValidation, 
    getMemberByIdValidation,
    validate
} from "../middlewares/member.validation";
import { MemberController } from "../controllers/member.controller";
import { authenticate } from "../middlewares/auth.middleware";
import { MemberRepository } from "../repositories/member.repository";
import prismaInstance from "../prisma";
import { MemberService } from "../services/member.service";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Members
 *   description: Manajemen data anggota perpustakaan
 */

/**
 * @swagger
 * /members:
 *   get:
 *     summary: Mendapatkan daftar member dengan pagination dan filter
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           minimum: 1
 *           default: 1
 *         description: Nomor halaman
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 100
 *           default: 10
 *         description: Jumlah data per halaman
 *       - in: query
 *         name: nama
 *         schema:
 *           type: string
 *         description: Filter berdasarkan nama member
 *       - in: query
 *         name: email
 *         schema:
 *           type: string
 *         description: Filter berdasarkan email member
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [ACTIVE, INACTIVE, SUSPENDED]
 *         description: Filter berdasarkan status member
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *           enum: [nama, email, createdAt, updatedAt]
 *           default: createdAt
 *         description: Field untuk sorting
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *           default: desc
 *         description: Urutan sorting
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar member
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Member'
 *                 pagination:
 *                   $ref: '#/components/schemas/Pagination'
 *       400:
 *         description: Parameter query tidak valid
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /members/stats:
 *   get:
 *     summary: Mendapatkan statistik status member
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       status:
 *                         type: string
 *                       count:
 *                         type: integer
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /members:
 *   post:
 *     summary: Membuat member baru
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - kodeMember
 *               - nama
 *               - email
 *               - telepon
 *             properties:
 *               kodeMember:
 *                 type: string
 *                 example: "MBR001"
 *               nama:
 *                 type: string
 *                 minLength: 3
 *                 example: Muhammad Harits
 *               email:
 *                 type: string
 *                 format: email
 *                 example: harits@example.com
 *               telepon:
 *                 type: string
 *                 pattern: '^[0-9]{10,13}$'
 *                 example: "083132212944"
 *               alamat:
 *                 type: string
 *                 example: "Jl. M. Ali No. 30"
 *               userId:
 *                 type: string
 *                 format: uuid
 *                 description: ID user jika terhubung dengan akun
 *                 example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       201:
 *         description: Member berhasil ditambahkan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Member'
 *       400:
 *         description: Validasi gagal atau kode/email sudah terdaftar
 *       401:
 *         description: Tidak terautentikasi
 */

/**
 * @swagger
 * /members/{id}:
 *   get:
 *     summary: Detail member berdasarkan ID
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Data member ditemukan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/MemberDetail'
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Member tidak ditemukan
 */

/**
 * @swagger
 * /members/{id}:
 *   put:
 *     summary: Update data member
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               kodeMember:
 *                 type: string
 *               nama:
 *                 type: string
 *               email:
 *                 type: string
 *                 format: email
 *               telepon:
 *                 type: string
 *               alamat:
 *                 type: string
 *               status:
 *                 type: string
 *                 enum: [ACTIVE, INACTIVE, SUSPENDED]
 *     responses:
 *       200:
 *         description: Member berhasil diperbarui
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Member'
 *       400:
 *         description: Validasi gagal atau kode sudah digunakan
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Member tidak ditemukan
 */

/**
 * @swagger
 * /members/{id}:
 *   delete:
 *     summary: Hapus member (Soft Delete - ubah status menjadi INACTIVE)
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         example: "123e4567-e89b-12d3-a456-426614174000"
 *     responses:
 *       200:
 *         description: Member berhasil dinonaktifkan
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   $ref: '#/components/schemas/Member'
 *       401:
 *         description: Tidak terautentikasi
 *       404:
 *         description: Member tidak ditemukan
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     Member:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           format: uuid
 *         kodeMember:
 *           type: string
 *         nama:
 *           type: string
 *         email:
 *           type: string
 *         telepon:
 *           type: string
 *         alamat:
 *           type: string
 *           nullable: true
 *         status:
 *           type: string
 *           enum: [ACTIVE, INACTIVE, SUSPENDED]
 *         createdAt:
 *           type: string
 *           format: date-time
 *         updatedAt:
 *           type: string
 *           format: date-time
 *     MemberDetail:
 *       allOf:
 *         - $ref: '#/components/schemas/Member'
 *         - type: object
 *           properties:
 *             user:
 *               type: object
 *               nullable: true
 *               properties:
 *                 id:
 *                   type: string
 *                   format: uuid
 *                 username:
 *                   type: string
 *                 name:
 *                   type: string
 *                 role:
 *                   type: string
 */

// --- Inisialisasi Layer ---
const repo = new MemberRepository(prismaInstance);
const service = new MemberService(repo);
const controller = new MemberController(service);

// --- Route Definitions ---
router.get('/', authenticate, controller.list);
router.get('/stats', authenticate, controller.getStats);
router.get('/:id', authenticate, validate(getMemberByIdValidation), controller.getById);
router.post('/', authenticate, validate(createMemberValidation), controller.create);
router.put('/:id', authenticate, validate(getMemberByIdValidation), controller.update);
router.delete('/:id', authenticate, validate(getMemberByIdValidation), controller.remove);

export default router;

--- FILE: ./routes/route.txt ---



--- FILE: ./transaction.route.ts ---

import { Router } from "express";
import { 
    borrowValidation, 
    returnValidation, 
    getByIdValidation, 
    getAllValidation 
} from "../middlewares/transaction.validation";
import { TransactionController } from "../controllers/transaction.controller";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import { TransactionRepository } from "../repositories/transaction.repository";
import { BookRepository } from "../repositories/book.repository";
import prismaInstance from "../prisma";
import { TransactionService } from "../services/transaction.service";

const router = Router();
/**
 * @swagger
 * tags:
 *   name: Transactions
 *   description: Manajemen peminjaman dan pengembalian buku
 */


/**
 * @swagger
 * /transactions:
 *   get:
 *     summary: Mendapatkan daftar semua transaksi
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: memberId
 *         schema:
 *           type: string
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [BORROWED, RETURNED, OVERDUE, CANCELLED]
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar transaksi
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 message:
 *                   type: string
 *                 data:
 *                   type: object
 *                   properties:
 *                     transactions:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Transaction'
 *                     total:
 *                       type: integer
 */


/**
 * @swagger
 * /transactions/stats:
 *   get:
 *     summary: Mendapatkan statistik transaksi
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 */


/**
 * @swagger
 * /transactions:
 *   post:
 *     summary: Membuat peminjaman buku baru
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - memberId
 *               - books
 *               - dueDate
 *             properties:
 *               memberId:
 *                 type: string
 *               dueDate:
 *                 type: string
 *                 format: date
 *                 example: "2025-12-31"
 *               books:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     bookId:
 *                       type: string
 *                     quantity:
 *                       type: integer
 *     responses:
 *       201:
 *         description: Peminjaman berhasil dicatat
 */


/**
 * @swagger
 * /transactions/{id}:
 *   get:
 *     summary: Detail transaksi berdasarkan ID
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Data ditemukan
 */


/**
 * @swagger
 * /transactions/return/{id}:
 *   patch:
 *     summary: Proses pengembalian buku
 *     tags: [Transactions]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Buku berhasil dikembalikan
 */


/**
 * @swagger
 * components:
 *   schemas:
 *     Transaction:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *         memberId:
 *           type: string
 *         status:
 *           type: string
 *         dueDate:
 *           type: string
 *           format: date-time
 *         returnDate:
 *           type: string
 *           format: date-time
 * */

// --- Inisialisasi Layer ---
const transactionRepo = new TransactionRepository(prismaInstance);
const bookRepo = new BookRepository(prismaInstance);
const service = new TransactionService(transactionRepo, bookRepo);
const controller = new TransactionController(service);

// --- Route Definitions ---
router.get('/', authenticate, validate(getAllValidation), controller.list);
router.get('/stats', authenticate, controller.getStats);
router.get('/:id', authenticate, validate(getByIdValidation), controller.getById);
router.post('/', authenticate, validate(borrowValidation), controller.create);
router.patch('/return/:id', authenticate, validate(returnValidation), controller.returnBooks);

export default router;

--- FILE: ./auth.route.ts ---

import { Router } from "express";
import { AuthController } from "../controllers/user.controller";
import { AuthService } from "../services/user.service";
import { UserRepository } from "../repositories/user.repository";
import { loginValidation, registerValidation } from "../middlewares/auth.validation";
import { validate } from "../utils/validator";  // Import validate yang benar
import { authenticate } from "../middlewares/auth.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Auth
 *   description: Operasi autentikasi pengguna (Login, Register, Profile)
 */

/**
 * @swagger
 * /auth/register:
 *   post:
 *     summary: Registrasi pengguna baru
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - username
 *               - email
 *               - password
 *               - name
 *             properties:
 *               username:
 *                 type: string
 *                 example: harits
 *               email:
 *                 type: string
 *                 format: email
 *                 example: harits@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 example: rahasia123
 *               name:
 *                 type: string
 *                 example: Muhammad Harits
 *               role:
 *                 type: string
 *                 enum: [ADMIN, LIBRARIAN, MEMBER]
 *                 example: MEMBER
 *     responses:
 *       201:
 *         description: Berhasil registrasi
 */

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: Login untuk mendapatkan token JWT
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - username
 *               - email
 *               - password
 *             properties:
 *               username:
 *                 type: string
 *                 example: harits
 *               email:
 *                 type: string
 *                 format: email
 *                 example: harits@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 example: rahasia123
 *     responses:
 *       200:
 *         description: Login berhasil
 */

/**
 * @swagger
 * /auth/me:
 *   get:
 *     summary: Mendapatkan profil user yang sedang login
 *     tags: [Auth]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Data profil berhasil diambil
 */

// Inisialisasi Layer (SAMA PERSIS dengan product API)
const repo = new UserRepository(prismaInstance);
const service = new AuthService(repo);
const controller = new AuthController(service);

// Endpoints (Pola sama dengan product API)
router.post("/register", validate(registerValidation), (req, res) => controller.register(req, res));
router.post("/login", validate(loginValidation), (req, res) => controller.login(req, res));
router.get("/me", authenticate, (req, res) => controller.me(req, res));

export default router;

--- FILE: ./author.route.ts ---

import { Router } from "express";
import { AuthorController } from "../controllers/author.controller";
import { AuthorService } from "../services/author.service";
import { AuthorRepository } from "../repositories/author.repository";
// Memperbaiki import agar sesuai dengan member yang di-export di author.validation.ts
import { 
    createAuthorValidation, 
    updateAuthorValidation, 
    getAuthorByIdValidation, 
    searchAuthorValidation 
} from "../middlewares/author.validation";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Authors
 *   description: Manajemen data penulis buku
 */

/**
 * @swagger
 * /authors:
 *   get:
 *     summary: Mendapatkan daftar semua penulis
 *     tags: [Authors]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: name
 *         schema:
 *           type: string
 *         description: Cari berdasarkan nama penulis
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar penulis
 */

/**
 * @swagger
 * /authors/stats:
 *   get:
 *     summary: Mendapatkan statistik penulis terproduktif
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 */

/**
 * @swagger
 * /authors:
 *   post:
 *     summary: Menambahkan penulis baru
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - birthDate
 *             properties:
 *               name:
 *                 type: string
 *               bio:
 *                 type: string
 *               birthDate:
 *                 type: string
 *                 format: date
 *                 example: "1990-01-01"
 *     responses:
 *       201:
 *         description: Penulis berhasil ditambahkan
 */

/**
 * @swagger
 * /authors/{id}:
 *   get:
 *     summary: Detail penulis beserta daftar bukunya
 *     tags: [Authors]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Data penulis ditemukan
 *   put:
 *     summary: Update data penulis
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               bio:
 *                 type: string
 *               birthDate:
 *                 type: string
 *                 format: date
 *     responses:
 *       200:
 *         description: Update berhasil
 *   delete:
 *     summary: Hapus data penulis
 *     tags: [Authors]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Penulis berhasil dihapus
 *       400:
 *         description: Gagal karena penulis masih memiliki buku aktif
 * */

// --- Inisialisasi Layer (Dependency Injection) ---
const repo = new AuthorRepository(prismaInstance);
const service = new AuthorService(repo);
const controller = new AuthorController(service);

// --- ROUTE URUTAN PENTING: STATS DULU, BARU :id ---

// 1. Route stats HARUS SEBELUM route :id
router.get("/stats", authenticate, (req, res) => controller.getStats(req, res));

// 2. Collection routes (tanpa ID)
router.get("/", 
    validate(searchAuthorValidation), 
    (req, res) => controller.list(req, res)
);

router.post("/", 
    authenticate, 
    validate(createAuthorValidation), 
    (req, res) => controller.create(req, res)
);

// 3. Member routes (dengan ID) - HARUS DI BAWAH
router.get("/:id", 
    validate(getAuthorByIdValidation), 
    (req, res) => controller.getById(req, res)
);

router.put("/:id", 
    authenticate, 
    validate(updateAuthorValidation), 
    (req, res) => controller.update(req, res)
);

router.delete("/:id", 
    authenticate, 
    validate(getAuthorByIdValidation), 
    (req, res) => controller.remove(req, res)
);

export default router;

--- FILE: ./book.route.ts ---

import { Router } from "express";
import { BookController } from "../controllers/book.controller";
import { BookService } from "../services/book.service";
import { BookRepository } from "../repositories/book.repository";
import { 
    createBookValidation, 
    updateBookValidation, 
    getBookByIdValidation, 
    searchBookValidation 
} from "../middlewares/book.validation";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import { upload } from "../middlewares/upload.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Books
 *   description: Manajemen data buku dan koleksi perpustakaan
 */

/**
 * @swagger
 * /books:
 *   get:
 *     summary: Mendapatkan daftar semua buku (dengan pagination & filter)
 *     tags: [Books]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: title
 *         schema:
 *           type: string
 *       - in: query
 *         name: authorId
 *         schema:
 *           type: string
 *       - in: query
 *         name: categoryId
 *         schema:
 *           type: string
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar buku
 */
/**
 * @swagger
 * /books/stats:
 *   get:
 *     summary: Mendapatkan statistik dashboard buku
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 */
/**
 * @swagger
 * /books:
 *   post:
 *     summary: Membuat buku baru (dengan upload cover)
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - isbn
 *               - year
 *               - stock
 *               - authorId
 *               - categoryId
 *               - coverImage
 *             properties:
 *               title:
 *                 type: string
 *               isbn:
 *                 type: string
 *               year:
 *                 type: integer
 *               stock:
 *                 type: integer
 *               authorId:
 *                 type: string
 *               categoryId:
 *                 type: string
 *               description:
 *                 type: string
 *               coverImage:
 *                 type: string
 *                 format: binary
 *     responses:
 *       201:
 *         description: Buku berhasil ditambahkan
 */
/**
 * @swagger
 * /books/{id}:
 *   get:
 *     summary: Detail buku berdasarkan ID
 *     tags: [Books]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Data buku ditemukan
 *   put:
 *     summary: Update data buku
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *               isbn:
 *                 type: string
 *               year:
 *                 type: integer
 *               stock:
 *                 type: integer
 *     responses:
 *       200:
 *         description: Update berhasil
 *   delete:
 *     summary: Hapus buku (Soft Delete)
 *     tags: [Books]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Buku berhasil dihapus
 * */

// --- Dependency Injection ---
const repo = new BookRepository(prismaInstance);
const service = new BookService(repo);
const controller = new BookController(service);

// --- Routes Definition ---

// 1. Stats diletakkan paling atas agar tidak bertabrakan dengan /:id
router.get("/stats", authenticate, controller.getStats);

// 2. Collection routes
router.get("/", searchBookValidation, validate, controller.list);
router.post(
    "/", 
    authenticate, 
    upload.single('coverImage'), 
    createBookValidation, 
    validate, 
    controller.create
);

// 3. Member routes (menggunakan :id)
router.get("/:id", getBookByIdValidation, validate, controller.getById);
router.put("/:id", authenticate, updateBookValidation, validate, controller.update);
router.delete("/:id", authenticate, getBookByIdValidation, validate, controller.remove);

export default router;

--- FILE: ./category.route.ts ---

import { Router } from "express";
import { CategoryController } from "../controllers/category.controller";
import { CategoryService } from "../services/category.service";
import { CategoryRepository } from "../repositories/category.repository";
import { validate } from "../utils/validator";
import { authenticate } from "../middlewares/auth.middleware";
import prismaInstance from "../prisma";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Categories
 *   description: Manajemen kategori buku
 */

/**
 * @swagger
 * /categories:
 *   get:
 *     summary: Mendapatkan daftar semua kategori
 *     tags: [Categories]
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: name
 *         schema:
 *           type: string
 *           description: Cari berdasarkan nama kategori
 *       - in: query
 *         name: sortBy
 *         schema:
 *           type: string
 *       - in: query
 *         name: sortOrder
 *         schema:
 *           type: string
 *           enum: [asc, desc]
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar kategori
 */

/**
 * @swagger
 * /categories/stats:
 *   get:
 *     summary: Mendapatkan statistik buku per kategori
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 */

/**
 * @swagger
 * /categories:
 *   post:
 *     summary: Membuat kategori baru
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *             properties:
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *     responses:
 *       201:
 *         description: Kategori berhasil dibuat
 */

/**
 * @swagger
 * /categories/{id}:
 *   get:
 *     summary: Detail kategori berdasarkan ID
 *     tags: [Categories]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Data kategori ditemukan
 *   put:
 *     summary: Update data kategori
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *     responses:
 *       200:
 *         description: Update kategori berhasil
 *   delete:
 *     summary: Hapus kategori
 *     tags: [Categories]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Kategori berhasil dihapus
 *       400:
 *         description: Gagal menghapus karena kategori masih memiliki buku
 * */

// --- Inisialisasi Layer (DI) ---
const repo = new CategoryRepository(prismaInstance);
const service = new CategoryService(repo);
const controller = new CategoryController(service);

// --- Route Definitions ---

// Route stats diletakkan sebelum :id
router.get("/stats", authenticate, controller.getStats);

router.get("/", controller.list);
router.post("/", authenticate, validate, controller.create);

router.get("/:id", controller.getById);
router.put("/:id", authenticate, validate, controller.update);
router.delete("/:id", authenticate, controller.remove);

export default router;

--- FILE: ./member.route.ts ---

import { Router } from "express";
import { 
    createMemberValidation, 
    getMemberByIdValidation,
    validate
} from "../middlewares/member.validation";
import { MemberController } from "../controllers/member.controller";
import { authenticate } from "../middlewares/auth.middleware";
import { MemberRepository } from "../repositories/member.repository";
import prismaInstance from "../prisma";
import { MemberService } from "../services/member.service";

const router = Router();

/**
 * @swagger
 * tags:
 *   name: Members
 *   description: Manajemen data anggota perpustakaan
 */

/**
 * @swagger
 * /members:
 *   get:
 *     summary: Mendapatkan daftar semua member
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: nama
 *         schema:
 *           type: string
 *       - in: query
 *         name: email
 *         schema:
 *           type: string
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [ACTIVE, INACTIVE, SUSPENDED]
 *     responses:
 *       200:
 *         description: Berhasil mengambil daftar member
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     members:
 *                       type: array
 *                       items:
 *                         $ref: '#/components/schemas/Member'
 *                     total:
 *                       type: integer
 */

/**
 * @swagger
 * /members/stats:
 *   get:
 *     summary: Mendapatkan statistik status member
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Statistik berhasil diambil
 */

/**
 * @swagger
 * /members:
 *   post:
 *     summary: Membuat member baru
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - nama
 *               - email
 *               - telepon
 *             properties:
 *               nama:
 *                 type: string
 *               email:
 *                 type: string
 *               telepon:
 *                 type: string
 *               alamat:
 *                 type: string
 *     responses:
 *       201:
 *         description: Member berhasil ditambahkan
 */

/**
 * @swagger
 * /members/{id}:
 *   get:
 *     summary: Detail member berdasarkan ID
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Data member ditemukan
 */

/**
 * @swagger
 * /members/{id}:
 *   delete:
 *     summary: Hapus member (Soft Delete)
 *     tags: [Members]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Member berhasil dinonaktifkan
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     Member:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         kodeMember:
 *           type: string
 *         nama:
 *           type: string
 *         email:
 *           type: string
 *         status:
 *           type: string
 * */

// --- Inisialisasi Layer ---
const repo = new MemberRepository(prismaInstance);
const service = new MemberService(repo);
const controller = new MemberController(service);

// --- Route Definitions ---
router.get('/', authenticate, controller.list);
router.get('/stats', authenticate, controller.getStats); // Stats di atas rute :id
router.get('/:id', authenticate, validate(getMemberByIdValidation), controller.getById);
router.post('/', authenticate, validate(createMemberValidation), controller.create);
router.put('/:id', authenticate, validate(getMemberByIdValidation), controller.update);
router.delete('/:id', authenticate, validate(getMemberByIdValidation), controller.remove);

export default router;

--- FILE: ./route.txt ---



--- FILE: ./services/author.service.ts ---

import type { Author, Prisma, Book } from "../generated/client";
import type { IAuthorRepository } from "../repositories/author.repository";

interface FindAllAuthorsParams {
    page: number;
    limit: number;
    search?: {
        name?: string;
    };
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
}

interface AuthorListResponse {
    authors: Author[];
    total: number;
    totalPages: number;
    currentPage: number;
}

export interface IAuthorService {
    list(params: FindAllAuthorsParams): Promise<AuthorListResponse>;
    getById(id: string): Promise<Author & { books: Book[] }>;
    create(data: Prisma.AuthorCreateInput): Promise<Author>;
    update(id: string, data: Prisma.AuthorUpdateInput): Promise<Author>;
    delete(id: string): Promise<Author>;
    getTopAuthors(): Promise<any>;
}

export class AuthorService implements IAuthorService {
    constructor(private authorRepo: IAuthorRepository) {}

    async list(params: FindAllAuthorsParams): Promise<AuthorListResponse> {
        const { page, limit, search, sortBy, sortOrder } = params;
        const skip = (page - 1) * limit;

        console.log(`AuthorService.list called with:`, { page, limit, skip, search, sortBy, sortOrder });

        const whereClause: Prisma.AuthorWhereInput = {};

        if (search?.name) {
            whereClause.name = { contains: search.name, mode: 'insensitive' };
        }

        const sortCriteria: Prisma.AuthorOrderByWithRelationInput = sortBy
            ? { [sortBy]: sortOrder || 'desc' }
            : { createdAt: 'desc' };

        console.log(`Fetching authors with where:`, whereClause);
        
        const authors = await this.authorRepo.list(skip, limit, whereClause, sortCriteria);
        console.log(`Found ${authors.length} authors`);
        
        const total = await this.authorRepo.countAll(whereClause);
        console.log(`Total authors: ${total}`);

        return {
            authors,
            total,
            totalPages: Math.ceil(total / limit),
            currentPage: page
        };
    }

    async getById(id: string): Promise<Author & { books: Book[] }> {
        console.log(`Fetching author by ID: ${id}`);
        const author = await this.authorRepo.findById(id);
        if (!author) {
            throw new Error("Penulis tidak ditemukan");
        }
        return author;
    }

    async create(data: Prisma.AuthorCreateInput): Promise<Author> {
        console.log(`Creating author: ${data.name}`);
        const existingAuthor = await this.authorRepo.findByName(data.name);
        if (existingAuthor) {
            throw new Error("Nama penulis sudah terdaftar");
        }
        return await this.authorRepo.create(data);
    }

    async update(id: string, data: Prisma.AuthorUpdateInput): Promise<Author> {
        console.log(`Updating author ID: ${id}`);
        await this.getById(id);
        
        if (data.name && typeof data.name === 'string') {
            const existingAuthor = await this.authorRepo.findByName(data.name);
            if (existingAuthor && existingAuthor.id !== id) {
                throw new Error("Nama penulis sudah digunakan");
            }
        }

        return await this.authorRepo.update(id, data);
    }

    async delete(id: string): Promise<Author> {
        console.log(`Deleting author ID: ${id}`);
        const author = await this.getById(id);
        
        if (author.books && author.books.length > 0) {
            throw new Error(`Gagal menghapus: Penulis masih memiliki ${author.books.length} buku. Hapus atau pindahkan buku terlebih dahulu.`);
        }

        return await this.authorRepo.delete(id);
    }

    async getTopAuthors() {
        console.log(`Fetching top authors stats`);
        return await this.authorRepo.getAuthorStats();
    }
}

--- FILE: ./services/category.service.ts ---

import type { Category, Prisma, Book } from "../generated/client";
import type { ICategoryRepository } from "../repositories/category.repository";

interface FindAllCategoriesParams {
    page: number;
    limit: number;
    search?: {
        name?: string;
    };
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
}

interface CategoryListResponse {
    categories: Category[];
    total: number;
    totalPages: number;
    currentPage: number;
}

export interface ICategoryService {
    list(params: FindAllCategoriesParams): Promise<CategoryListResponse>;
    getById(id: string): Promise<Category & { books: Book[] }>;
    create(data: Prisma.CategoryCreateInput): Promise<Category>;
    update(id: string, data: Prisma.CategoryUpdateInput): Promise<Category>;
    delete(id: string): Promise<Category>;
    getStats(): Promise<any>;
}

export class CategoryService implements ICategoryService {
    constructor(private categoryRepo: ICategoryRepository) {}

    async list(params: FindAllCategoriesParams): Promise<CategoryListResponse> {
        const { page, limit, search, sortBy, sortOrder } = params;
        const skip = (page - 1) * limit;

        const whereClause: Prisma.CategoryWhereInput = {};

        if (search?.name) {
            whereClause.name = { contains: search.name, mode: 'insensitive' };
        }

        const sortCriteria: Prisma.CategoryOrderByWithRelationInput = sortBy
            ? { [sortBy]: sortOrder || 'desc' }
            : { createdAt: 'desc' };

        const categories = await this.categoryRepo.list(skip, limit, whereClause, sortCriteria);
        const total = await this.categoryRepo.countAll(whereClause);

        return {
            categories,
            total,
            totalPages: Math.ceil(total / limit),
            currentPage: page
        };
    }

    async getById(id: string): Promise<Category & { books: Book[] }> {
        const category = await this.categoryRepo.findById(id);
        if (!category) {
            throw new Error("Kategori tidak ditemukan");
        }
        return category;
    }

    async create(data: Prisma.CategoryCreateInput): Promise<Category> {
        // Nama kategori biasanya unik, Prisma akan melempar error jika duplikat
        // sesuai dengan atribut @unique di skema kamu.
        return await this.categoryRepo.create(data);
    }

    async update(id: string, data: Prisma.CategoryUpdateInput): Promise<Category> {
        await this.getById(id);
        return await this.categoryRepo.update(id, data);
    }

    async delete(id: string): Promise<Category> {
        const category = await this.getById(id);
        
        // Logic tambahan: Cegah hapus kategori jika masih ada buku di dalamnya
        if (category.books && category.books.length > 0) {
            throw new Error("Kategori tidak bisa dihapus karena masih memiliki buku aktif");
        }

        return await this.categoryRepo.delete(id);
    }

    /**
     * Mengikuti pola exec() di ProductService Anda
     */
    async getStats() {
        const bookCounts = await this.categoryRepo.getCategoryBookStats();
        
        // Kita bisa memperkaya data ini dengan mengambil nama kategori 
        // agar dashboard tidak hanya menampilkan ID
        const categories = await this.categoryRepo.list(0, 100, {}, {});

        return bookCounts.map(stat => {
            const categoryName = categories.find(c => c.id === stat.categoryId)?.name || "Unknown";
            return {
                categoryName,
                totalBooks: stat._count.id
            };
        });
    }
}

--- FILE: ./services/member.service.ts ---

import type { Member, Prisma, User } from "../generated/client";
import type { IMemberRepository } from "../repositories/member.repository";

interface FindAllMembersParams {
    page: number;
    limit: number;
    search?: {
        nama?: string;
        email?: string;
        status?: "ACTIVE" | "INACTIVE" | "SUSPENDED";
    };
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
}

interface MemberListResponse {
    members: Member[];
    total: number;
    totalPages: number;
    currentPage: number;
}

export interface IMemberService {
    list(params: FindAllMembersParams): Promise<MemberListResponse>;
    getById(id: string): Promise<Member & { user?: User | null }>;
    create(data: Prisma.MemberCreateInput): Promise<Member>;
    update(id: string, data: Prisma.MemberUpdateInput): Promise<Member>;
    delete(id: string): Promise<Member>;
    getStats(): Promise<any>;
}

export class MemberService implements IMemberService {
    constructor(private memberRepo: IMemberRepository) {}

    async list(params: FindAllMembersParams): Promise<MemberListResponse> {
        const { page, limit, search, sortBy, sortOrder } = params;
        const skip = (page - 1) * limit;

        const whereClause: Prisma.MemberWhereInput = {};

        if (search?.nama) {
            whereClause.nama = { contains: search.nama, mode: 'insensitive' };
        }
        if (search?.email) {
            whereClause.email = { contains: search.email, mode: 'insensitive' };
        }
        if (search?.status) {
            whereClause.status = search.status;
        }

        const sortCriteria: Prisma.MemberOrderByWithRelationInput = sortBy
            ? { [sortBy]: sortOrder || 'desc' }
            : { createdAt: 'desc' };

        const members = await this.memberRepo.list(skip, limit, whereClause, sortCriteria);
        const total = await this.memberRepo.countAll(whereClause);

        return {
            members,
            total,
            totalPages: Math.ceil(total / limit),
            currentPage: page
        };
    }

    async getById(id: string): Promise<Member & { user?: User | null }> {
        const member = await this.memberRepo.findById(id);
        if (!member) {
            throw new Error("Member tidak ditemukan");
        }
        return member as any;
    }

    async create(data: Prisma.MemberCreateInput): Promise<Member> {
        // 1. Validasi Kode Member Unik
        const existingKode = await this.memberRepo.findByKodeMember(data.kodeMember);
        if (existingKode) {
            throw new Error("Kode Member sudah terdaftar");
        }

        // 2. Validasi Email Unik
        // Catatan: Anda bisa menambahkan method findByEmail di repository member jika diperlukan
        
        return await this.memberRepo.create(data);
    }

    async update(id: string, data: Prisma.MemberUpdateInput): Promise<Member> {
        await this.getById(id);

        // Validasi jika kode member diubah dan ternyata sudah dipakai orang lain
        if (data.kodeMember && typeof data.kodeMember === 'string') {
            const existingMember = await this.memberRepo.findByKodeMember(data.kodeMember);
            if (existingMember && existingMember.id !== id) {
                throw new Error("Kode Member sudah digunakan oleh member lain");
            }
        }

        return await this.memberRepo.update(id, data);
    }

    async delete(id: string): Promise<Member> {
        await this.getById(id);
        // Menggunakan softDelete yang mengubah status menjadi INACTIVE
        return await this.memberRepo.softDelete(id);
    }

    async getStats() {
        const stats = await this.memberRepo.getStatusStats();
        
        // Transformasi data agar lebih mudah dibaca di frontend
        return stats.map(s => ({
            status: s.status,
            count: s._count.id
        }));
    }
}

--- FILE: ./services/transaction.service.ts ---

import type { Prisma, Transaction, TransactionItem, Book } from "../generated/client";
import type { ITransactionRepository } from "../repositories/transaction.repository";
import type { IBookRepository } from "../repositories/book.repository";

interface FindAllParams {
    page: number;
    limit: number;
    memberId?: string;
    status?: "BORROWED" | "RETURNED" | "OVERDUE" | "CANCELLED";
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
}

interface TransactionListResponse {
    transactions: Transaction[];
    total: number;
    totalPages: number;
    currentPage: number;
}

export interface ITransactionService {
    list(params: FindAllParams): Promise<TransactionListResponse>;
    getById(id: string): Promise<Transaction & { items: TransactionItem[] }>;
    // Data input mirip dengan pola Order Anda (userId -> memberId)
    create(data: { memberId: string; items: { bookId: string; quantity: number }[]; dueDate: Date }): Promise<Transaction>;
    returnBooks(id: string): Promise<Transaction>;
    exec(): Promise<{ overview: any }>;
}

export class TransactionService implements ITransactionService {
    constructor(
        private transactionRepo: ITransactionRepository,
        private bookRepo: IBookRepository
    ) {}

    async list(params: FindAllParams): Promise<TransactionListResponse> {
        const { page, limit, memberId, status, sortBy, sortOrder } = params;
        const skip = (page - 1) * limit;

        const whereClause: Prisma.TransactionWhereInput = {};
        if (memberId) whereClause.memberId = memberId;
        if (status) whereClause.status = status;

        const sortCriteria: Prisma.TransactionOrderByWithRelationInput = sortBy
            ? { [sortBy]: sortOrder || 'desc' }
            : { createdAt: 'desc' };

        const transactions = await this.transactionRepo.list(skip, limit, whereClause, sortCriteria);
        const total = await this.transactionRepo.countAll(whereClause);

        return { 
            transactions, 
            total, 
            totalPages: Math.ceil(total / limit), 
            currentPage: page 
        };
    }

    async getById(id: string): Promise<Transaction & { items: TransactionItem[] }> {
        const transaction = await this.transactionRepo.findById(id);
        if (!transaction) throw new Error("Transaksi tidak ditemukan");
        return transaction;
    }

    /**
     * Mengikuti pola Create Order Anda:
     * 1. Cek ketersediaan buku (stock)
     * 2. Kurangi stok buku
     * 3. Simpan transaksi peminjaman
     */
    async create(data: { memberId: string; items: { bookId: string; quantity: number }[]; dueDate: Date }): Promise<Transaction> {
        // 1. Validasi stok buku
        for (const item of data.items) {
            const bookData = await this.bookRepo.findById(item.bookId);
            if (!bookData) {
                throw new Error(`Buku dengan ID ${item.bookId} tidak ditemukan`);
            }

            const book = bookData as unknown as Book;

            if (book.stock < item.quantity) {
                throw new Error(`Stok buku "${book.title}" tidak mencukupi (Tersedia: ${book.stock})`);
            }

            // 2. Kurangi stok buku
            await this.bookRepo.update(book.id, { 
                stock: book.stock - item.quantity 
            });
        }

        // 3. Simpan transaksi
        return await this.transactionRepo.create({
            member: { connect: { id: data.memberId } },
            status: 'BORROWED',
            dueDate: data.dueDate,
            items: {
                create: data.items.map(item => ({
                    quantity: item.quantity,
                    book: { connect: { id: item.bookId } }
                }))
            }
        });
    }

    /**
     * Logika khusus Library: Mengembalikan buku
     * 1. Ubah status jadi RETURNED
     * 2. Tambahkan kembali stok buku yang dipinjam
     */
    async returnBooks(id: string): Promise<Transaction> {
        const transaction = await this.getById(id);

        if (transaction.status === 'RETURNED') {
            throw new Error("Buku dalam transaksi ini sudah dikembalikan");
        }

        // Update stok: Kembalikan buku ke rak (tambah stok)
        for (const item of transaction.items) {
            const book = await this.bookRepo.findById(item.bookId);
            if (book) {
                await this.bookRepo.update(item.bookId, {
                    stock: (book as unknown as Book).stock + item.quantity
                });
            }
        }

        // Update status transaksi
        return await this.transactionRepo.update(id, {
            status: 'RETURNED',
            returnDate: new Date()
        });
    }

    async exec() {
        const stats = await this.transactionRepo.getStats();
        return { overview: stats };
    }
}

--- FILE: ./services/book.service.ts ---

import type { Prisma, Book } from "../generated/client";
import type { IBookRepository } from "../repositories/book.repository";

interface FindAllBooksParams {
    page: number;
    limit: number;
    search?: { 
        title?: string;
        authorId?: string;
        categoryId?: string;
    };
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
}

interface BookListResponse {
    books: Book[]; 
    total: number; 
    totalPages: number; 
    currentPage: number;
}

export interface IBookService {
    list(params: FindAllBooksParams): Promise<BookListResponse>;
    getById(id: string): Promise<Book>;
    create(data: Prisma.BookCreateInput): Promise<Book>;
    update(id: string, data: Prisma.BookUpdateInput): Promise<Book>;
    delete(id: string): Promise<Book>;
    getDashboardStats(): Promise<{
        totalAvailableBooks: number;
        activeTransactions: number;
        popularBook: string;
    }>;
}

export class BookService implements IBookService {
    constructor(private bookRepo: IBookRepository) {}

    async list(params: FindAllBooksParams): Promise<BookListResponse> {
        const { page, limit, search, sortBy, sortOrder } = params;

        const skip = (page - 1) * limit;

        // Filter dasar untuk Soft Delete
        const whereClause: Prisma.BookWhereInput = { deletedAt: null };

        // Pencarian spesifik Buku
        if (search?.title) {
            whereClause.title = { contains: search.title, mode: 'insensitive' };
        }
        if (search?.authorId) {
            whereClause.authorId = search.authorId;
        }
        if (search?.categoryId) {
            whereClause.categoryId = search.categoryId;
        }

        const sortCriteria: Prisma.BookOrderByWithRelationInput = sortBy
            ? { [sortBy]: sortOrder || 'desc' } 
            : { createdAt: 'desc' };

        const books = await this.bookRepo.list(skip, limit, whereClause, sortCriteria);
        const total = await this.bookRepo.countAll(whereClause);

        return { 
            books, 
            total, 
            totalPages: Math.ceil(total / limit), 
            currentPage: page 
        };
    }

    async getById(id: string): Promise<Book> {
        const book = await this.bookRepo.findById(id);

        if (!book) {
            throw new Error("Buku tidak ditemukan atau sudah dihapus");
        }

        return book;
    }

    async create(data: Prisma.BookCreateInput): Promise<Book> {
        // Kamu bisa menambahkan validasi ISBN unik di sini sebelum create
        return await this.bookRepo.create(data);
    }

    async update(id: string, data: Prisma.BookUpdateInput): Promise<Book> {
        // Pastikan buku ada sebelum diupdate
        await this.getById(id);
        return await this.bookRepo.update(id, data);
    }

    async delete(id: string): Promise<Book> {
        // Pastikan buku ada sebelum didelete
        await this.getById(id);
        return await this.bookRepo.softDelete(id);
    }

    async getDashboardStats() {
        // Memanggil method khusus analytics yang sudah kamu buat di repository
        return await this.bookRepo.getAdminStats();
    }
}

--- FILE: ./services/user.service.ts ---

import type { User, Prisma } from "../generated/client";
import type { IUserRepository } from "../repositories/user.repository"; 
import * as bcrypt from "bcrypt";
import jwt from "jsonwebtoken";  // Import default, bukan * as
import config from "../utils/env";  // Gunakan config dari env

interface AuthResponse {
    user: Omit<User, "password">;
    token: string;
}

export interface IAuthService {
    register(data: Prisma.UserCreateInput): Promise<Omit<User, "password">>;
    login(email: string, password: string): Promise<AuthResponse>;
    me(userId: string): Promise<Omit<User, "password">>;
}

export class AuthService implements IAuthService {
    constructor(private userRepo: IUserRepository) {}

    async register(data: Prisma.UserCreateInput): Promise<Omit<User, "password">> {
        // 1. Cek duplikasi email
        const existingEmail = await this.userRepo.findByEmail(data.email);
        if (existingEmail) {
            throw new Error("Email sudah digunakan");
        }

        // 2. Cek duplikasi username
        const existingUsername = await this.userRepo.findByUsername(data.username);
        if (existingUsername) {
            throw new Error("Username sudah digunakan");
        }

        // 3. Hash Password
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(data.password, salt);

        // 4. Simpan ke Database (SAMA dengan product API)
        const user = await this.userRepo.create({
            ...data,
            password: hashedPassword
        });

        // 5. Hilangkan password dari return object
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
    }

    async login(email: string, passwordInput: string): Promise<AuthResponse> {
        // 1. Cari user
        const user = await this.userRepo.findByEmail(email);
        if (!user) {
            throw new Error("Email atau password salah");
        }

        // 2. Bandingkan password (SAMA dengan product API)
        const isMatch = await bcrypt.compare(passwordInput, user.password);
        if (!isMatch) {
            throw new Error("Email atau password salah");
        }

        // 3. Generate JWT (Pakai config dari env)
        const token = jwt.sign(
            { 
                id: user.id, 
                role: user.role, 
                name: user.name,
                email: user.email 
            },
            config.JWT_SECRET,
            { expiresIn: config.JWT_EXPIRES_IN || '1d' }
        );

        const { password, ...userWithoutPassword } = user;
        return {
            user: userWithoutPassword,
            token
        };
    }

    async me(userId: string): Promise<Omit<User, "password">> {
        const user = await this.userRepo.findById(userId);
        
        if (!user) {
            throw new Error("User tidak ditemukan");
        }

        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
    }
}

--- FILE: ./types/express.d.ts ---

import type { Request } from "express"

declare global {
    namespace Express {
        interface Request {
            startTime?: number;
            apiKey?: string;
            user?: {  
                id: string;
                role: string;
                memberId?: string;
            }
        }
    }
}

--- FILE: ./utils/response.ts ---

import type { Response } from "express";

export interface ApiResponse {
    success: boolean;
    message: string;
    data?: unknown;
    pagination?: {
        page: number;
        limit: number;
        total: number;
    };
    errors?: Array<{
        field: string;
        message: string;
    }> | { stack?: string };
}

export const successResponse = (
    res: Response,
    message: string,
    data: unknown | null,
    pagination: { page: number; limit: number; total: number } | null = null,
    statusCode: number = 200
) => {
    const response: ApiResponse = {
        success: true,
        message
    }

    if (data !== null) response.data = data
    if (pagination) response.pagination = pagination

    return res.status(statusCode).json(response)
}

export const errorResponse = (
    res: Response,
    message: string,
    statusCode: number = 400,
    errors: Array<{ field: string; message: string }> | { stack?: string } | null = null
) => {
    const response: ApiResponse = {
        success: false,
        message,
    };

    if (errors) response.errors = errors;

    return res.status(statusCode).json(response);
}

--- FILE: ./utils/async.handler.ts ---

import type { NextFunction, Request, Response } from "express";

export const asyncHandler = (fn: Function) => {
    return (req: Request, res: Response, next: NextFunction) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
};

--- FILE: ./utils/validator.ts ---

import type { Request, Response, NextFunction } from "express"
import { validationResult, type ValidationChain } from "express-validator"
import { errorResponse } from "./response"

export const validate = (validations: ValidationChain[]) => {
    return async (req: Request, res: Response, next: NextFunction) => {
        await Promise.all(validations.map(validation => validation.run(req)))

        const errors = validationResult(req)
        if (errors.isEmpty()) {
            return next()
        }

        const errorList = errors.array().map(err => ({
            field: err.type === 'field' ? err.path : 'unknown',
            message: err.msg
        }))

        return errorResponse(res, "Validasi gagal", 400, errorList)
    }
}

--- FILE: ./utils/env.ts ---

import dotenv from 'dotenv'

dotenv.config()

export default {
    HOST: process.env.HOST || 'localhost',
    PORT: process.env.PORT || 3000,
    NODE_ENV: process.env.NODE_ENV || 'development',
    DATABASE_URL: process.env.DATABASE_URL || 'postgresql://muharits:640559@localhost:5432/library_db',
    JWT_SECRET: process.env.JWT_SECRET || 'library_secret_key',
    JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || '7d',
} as const

--- FILE: ./utils/swagger.ts ---

import config from './env'
import swaggerJSDoc from 'swagger-jsdoc'

const options: swaggerJSDoc.Options = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'E-Commerce API E-Commerce',
            version: '1.0.0',
            description: 'Dokumentasi lengkap API E-Commerce',
            contact: {
                name: 'Backend Developer',
            }
        },
        servers: [
            {
                url: `http://${config.HOST}:${config.PORT}/api`,
                description: 'Development server'
            }
        ],
        components: {
            securitySchemes: {
                bearerAuth:{
                    type: 'http',
                    scheme: 'bearer',
                    bearerFormat: 'JWT',
                }
            }
        },
        security: [
            {
                bearerAuth: [],
            }
        ]
    },
    apis: ['src/routes/*.ts'],
}

const swaggerSpec = swaggerJSDoc(options)

export default swaggerSpec

--- FILE: ./prisma/migrations/20251213022953/migration.sql ---

-- CreateTable
CREATE TABLE "books" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "isbn" TEXT NOT NULL,
    "description" TEXT,
    "year" INTEGER NOT NULL,
    "stock" INTEGER NOT NULL DEFAULT 0,
    "authorId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "books_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "authors" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "bio" TEXT,
    "birthDate" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "authors_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "books_isbn_key" ON "books"("isbn");

-- AddForeignKey
ALTER TABLE "books" ADD CONSTRAINT "books_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "authors"("id") ON DELETE CASCADE ON UPDATE CASCADE;


--- FILE: ./prisma/migrations/migration_lock.toml ---

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"


--- FILE: ./prisma/migrations/20251220062644/migration.sql ---

/*
  Warnings:

  - Added the required column `categoryId` to the `books` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "books" ADD COLUMN     "categoryId" TEXT NOT NULL;

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "books" ADD CONSTRAINT "books_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE CASCADE ON UPDATE CASCADE;


--- FILE: ./prisma/migrations/20251220064117/migration.sql ---

/*
  Warnings:

  - You are about to drop the `Category` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "TransactionStatus" AS ENUM ('BORROWED', 'RETURNED', 'OVERDUE', 'CANCELLED');

-- DropForeignKey
ALTER TABLE "books" DROP CONSTRAINT "books_categoryId_fkey";

-- DropTable
DROP TABLE "Category";

-- CreateTable
CREATE TABLE "categories" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "categories_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "transactions" (
    "id" TEXT NOT NULL,
    "memberId" TEXT NOT NULL,
    "borrowDate" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "dueDate" TIMESTAMP(3) NOT NULL,
    "returnDate" TIMESTAMP(3),
    "status" "TransactionStatus" NOT NULL DEFAULT 'BORROWED',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "transactions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "transaction_items" (
    "id" TEXT NOT NULL,
    "transactionId" TEXT NOT NULL,
    "bookId" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL DEFAULT 1,

    CONSTRAINT "transaction_items_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "transaction_items_transactionId_idx" ON "transaction_items"("transactionId");

-- CreateIndex
CREATE INDEX "transaction_items_bookId_idx" ON "transaction_items"("bookId");

-- AddForeignKey
ALTER TABLE "books" ADD CONSTRAINT "books_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "categories"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "transaction_items" ADD CONSTRAINT "transaction_items_transactionId_fkey" FOREIGN KEY ("transactionId") REFERENCES "transactions"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "transaction_items" ADD CONSTRAINT "transaction_items_bookId_fkey" FOREIGN KEY ("bookId") REFERENCES "books"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


--- FILE: ./prisma/migrations/20251220065442/migration.sql ---

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "role" TEXT NOT NULL DEFAULT 'USER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");


--- FILE: ./prisma/migrations/20251220071252/migration.sql ---

-- CreateTable
CREATE TABLE "members" (
    "id" TEXT NOT NULL,
    "nama" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "telepon" TEXT NOT NULL,
    "alamat" TEXT,
    "tanggal_daftar" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "members_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "members_email_key" ON "members"("email");

-- AddForeignKey
ALTER TABLE "transactions" ADD CONSTRAINT "transactions_memberId_fkey" FOREIGN KEY ("memberId") REFERENCES "members"("id") ON DELETE CASCADE ON UPDATE CASCADE;


--- FILE: ./prisma/migrations/20251220073456/migration.sql ---

/*
  Warnings:

  - A unique constraint covering the columns `[name]` on the table `categories` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[kodeMember]` on the table `members` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[username]` on the table `users` will be added. If there are existing duplicate values, this will fail.
  - Added the required column `description` to the `categories` table without a default value. This is not possible if the table is not empty.
  - Added the required column `kodeMember` to the `members` table without a default value. This is not possible if the table is not empty.
  - Added the required column `username` to the `users` table without a default value. This is not possible if the table is not empty.

*/
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('ADMIN', 'LIBRARIAN', 'MEMBER');

-- CreateEnum
CREATE TYPE "MemberStatus" AS ENUM ('ACTIVE', 'INACTIVE', 'SUSPENDED');

-- AlterTable
ALTER TABLE "categories" ADD COLUMN     "description" TEXT NOT NULL;

-- AlterTable
ALTER TABLE "members" ADD COLUMN     "kodeMember" TEXT NOT NULL,
ADD COLUMN     "status" "MemberStatus" NOT NULL DEFAULT 'ACTIVE',
ADD COLUMN     "userId" TEXT;

-- AlterTable
ALTER TABLE "users" ADD COLUMN     "username" TEXT NOT NULL;

-- CreateIndex
CREATE UNIQUE INDEX "categories_name_key" ON "categories"("name");

-- CreateIndex
CREATE UNIQUE INDEX "members_kodeMember_key" ON "members"("kodeMember");

-- CreateIndex
CREATE UNIQUE INDEX "users_username_key" ON "users"("username");

-- AddForeignKey
ALTER TABLE "members" ADD CONSTRAINT "members_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE SET NULL ON UPDATE CASCADE;


--- FILE: ./prisma/migrations/20251220075629/migration.sql ---

/*
  Warnings:

  - A unique constraint covering the columns `[name]` on the table `authors` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "authors_name_key" ON "authors"("name");


--- FILE: ./prisma/migrations/20251220093555/migration.sql ---

-- AlterTable
ALTER TABLE "books" ADD COLUMN     "coverImage" TEXT;


--- FILE: ./prisma/migrations/20251229034559/migration.sql ---

/*
  Warnings:

  - The `role` column on the `users` table would be dropped and recreated. This will lead to data loss if there is data in the column.

*/
-- AlterTable
ALTER TABLE "users" DROP COLUMN "role",
ADD COLUMN     "role" "UserRole" NOT NULL DEFAULT 'MEMBER';


--- FILE: ./prisma/schema.prisma ---

generator client {
  provider = "prisma-client"
  output   = "../generated"
}

datasource db {
  provider = "postgresql"
}

model Book {
  id           String            @id @default(uuid())
  title        String
  isbn         String            @unique
  description  String?
  year         Int
  stock        Int               @default(0)
  coverImage   String?

  authorId     String
  author       Author            @relation(fields: [authorId], references: [id], onDelete: Cascade)

  categoryId   String
  category     Category          @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  items        TransactionItem[]

  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  deletedAt    DateTime?

  @@map("books")
}

model Author {
  id        String   @id @default(uuid())
  name      String   @unique
  bio       String?
  birthDate DateTime

  books     Book[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("authors")
}

// Tambahkan model User di bawah Author
model User {
  id        String    @id @default(uuid())
  username  String    @unique
  name      String
  email     String    @unique
  password  String
  role      UserRole  @default(MEMBER)

  member    Member[]
  
  // Hapus relation ke transactions jika tidak ada model Transaction
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  @@map("users")
}

model Member {
  id              String    @id @default(uuid())
  kodeMember      String    @unique
  nama            String
  email           String    @unique
  telepon         String
  alamat          String?
  tanggal_daftar  DateTime  @default(now())
  status          MemberStatus  @default(ACTIVE)

  userId          String?
  user            User?     @relation(fields: [userId], references: [id])
  
  transactions    Transaction[] // Relation ke transactions jika ada
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@map("members")
}

model Category {
  id        String   @id @default(uuid())
  name      String   @unique
  description String


  books     Book[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("categories")
}

model Transaction {
  id         String              @id @default(uuid())

  memberId   String
  member     Member              @relation(fields: [memberId], references: [id], onDelete: Cascade)

  items      TransactionItem[]

  borrowDate DateTime            @default(now())
  dueDate    DateTime
  returnDate DateTime?
  status     TransactionStatus   @default(BORROWED)

  createdAt  DateTime            @default(now())
  updatedAt  DateTime            @updatedAt

  @@map("transactions")
}

model TransactionItem {
  id             String        @id @default(uuid())

  transactionId  String
  transaction    Transaction  @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  bookId         String
  book           Book         @relation(fields: [bookId], references: [id])

  quantity       Int           @default(1)

  @@index([transactionId])
  @@index([bookId])
  @@map("transaction_items")
}

// ENUMS
enum UserRole {
  ADMIN      // Super admin
  LIBRARIAN  // Pustakawan
  MEMBER     // Anggota yang bisa login
}

enum MemberStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum TransactionStatus {
  BORROWED
  RETURNED
  OVERDUE
  CANCELLED
}



--- FILE: ./prisma/seeder.ts ---

import { faker } from '@faker-js/faker';
import bcrypt from 'bcrypt';
import { getPrisma } from '../prisma';
import fs from 'fs';
import path from 'path';

const prisma = getPrisma();

// Config
const NUM_ADMINS = 2;
const NUM_LIBRARIANS = 3;
const NUM_MEMBERS = 20;
const NUM_AUTHORS = 15;
const NUM_CATEGORIES = 8;
const NUM_BOOKS = 50;
const NUM_TRANSACTIONS = 30;

// Fixed credentials for testing
const TEST_CREDENTIALS = {
  ADMIN: { password: 'admin123' },
  LIBRARIAN: { password: 'librarian123' },
  MEMBER: { password: 'member123' }
};

async function findOrCreateAuthor(name: string, bio: string, birthDate: Date) {
  const existingAuthor = await prisma.author.findFirst({
    where: { name }
  });
  
  if (existingAuthor) {
    return existingAuthor;
  }
  
  return await prisma.author.create({
    data: { name, bio, birthDate }
  });
}

async function seedData() {
  console.log(' Starting database seeding...');
  console.log('='.repeat(50));

  // Clear existing data
  console.log(' Clearing existing data...');
  await prisma.transactionItem.deleteMany();
  await prisma.transaction.deleteMany();
  await prisma.book.deleteMany();
  await prisma.author.deleteMany();
  await prisma.category.deleteMany();
  await prisma.member.deleteMany();
  await prisma.user.deleteMany();

  // Arrays to store created data
  const createdData = {
    admins: [] as any[],
    librarians: [] as any[],
    members: [] as any[],
    users: [] as any[],
    categories: [] as any[],
    authors: [] as any[],
    books: [] as any[],
    membersData: [] as any[]
  };

  // ======================
  // 1. SEED USERS
  // ======================
  console.log('\n Seeding users...');
  
  // Admin Users (fixed emails for easy testing)
  for (let i = 1; i <= NUM_ADMINS; i++) {
    const email = `admin${i}@library.com`;
    const password = await bcrypt.hash(TEST_CREDENTIALS.ADMIN.password, 10);
    
    const admin = await prisma.user.create({
      data: {
        username: `admin${i}`,
        email,
        password,
        name: `Admin ${i}`,
        role: 'ADMIN',
      },
    });
    
    createdData.admins.push(admin);
    createdData.users.push(admin);
    console.log(`   Admin ${i}: ${email} / ${TEST_CREDENTIALS.ADMIN.password}`);
  }

  // Librarian Users (fixed emails for testing)
  for (let i = 1; i <= NUM_LIBRARIANS; i++) {
    const email = `librarian${i}@library.com`;
    const password = await bcrypt.hash(TEST_CREDENTIALS.LIBRARIAN.password, 10);
    
    const librarian = await prisma.user.create({
      data: {
        username: `librarian${i}`,
        email,
        password,
        name: `Petugas Perpustakaan ${i}`,
        role: 'LIBRARIAN',
      },
    });
    
    createdData.librarians.push(librarian);
    createdData.users.push(librarian);
    console.log(`   Librarian ${i}: ${email} / ${TEST_CREDENTIALS.LIBRARIAN.password}`);
  }

  // Member Users (fixed first 5 for testing, rest random)
  for (let i = 1; i <= NUM_MEMBERS; i++) {
    // First 5 members have fixed emails for testing
    const email = i <= 5 
      ? `member${i}@library.com`
      : faker.internet.email();
    
    const password = await bcrypt.hash(TEST_CREDENTIALS.MEMBER.password, 10);
    const name = i <= 5 
      ? `Anggota ${i}`
      : faker.person.fullName();
    
    const user = await prisma.user.create({
      data: {
        username: i <= 5 ? `member${i}` : faker.internet.username(),
        email,
        password,
        name,
        role: 'MEMBER',
      },
    });
    
    const member = await prisma.member.create({
      data: {
        kodeMember: `MEM${String(i).padStart(4, '0')}`,
        nama: name,
        email,
        telepon: faker.helpers.fromRegExp(/08[0-9]{10}/),
        alamat: faker.location.streetAddress(),
        status: faker.helpers.arrayElement(['ACTIVE', 'ACTIVE', 'ACTIVE', 'INACTIVE']),
        userId: user.id,
      },
    });
    
    createdData.members.push(user);
    createdData.membersData.push(member);
    createdData.users.push(user);
    
    if (i <= 5) {
      console.log(`   Member ${i}: ${email} / ${TEST_CREDENTIALS.MEMBER.password}`);
    }
  }

  // ======================
  // 2. SEED CATEGORIES
  // ======================
  console.log('\n Seeding categories...');
  const categoryNames = [
    'Fiksi', 'Non-Fiksi', 'Pendidikan', 'Teknologi', 
    'Sastra', 'Sejarah', 'Bisnis', 'Psikologi'
  ];
  
  for (let i = 0; i < NUM_CATEGORIES; i++) {
    const category = await prisma.category.create({
      data: {
        name: categoryNames[i] || faker.word.noun(),
        description: faker.lorem.sentence(),
      },
    });
    createdData.categories.push(category);
    console.log(`   Category: ${category.name}`);
  }

  // ======================
  // 3. SEED AUTHORS
  // ======================
  console.log('\n Seeding authors...');
  
  // Popular Indonesian authors (fixed for realism)
  const popularAuthors = [
    { name: 'Andrea Hirata', bio: 'Penulis novel bestseller Laskar Pelangi', birthDate: new Date('1967-10-24') },
    { name: 'Pramoedya Ananta Toer', bio: 'Sastrawan Indonesia terkemuka', birthDate: new Date('1925-02-06') },
    { name: 'Tere Liye', bio: 'Penulis novel Indonesia kontemporer', birthDate: new Date('1979-05-21') },
    { name: 'Dee Lestari', bio: 'Penulis dan penyanyi Indonesia', birthDate: new Date('1976-01-20') },
    { name: 'Eka Kurniawan', bio: 'Penulis novel Cantik Itu Luka', birthDate: new Date('1975-11-28') },
  ];
  
  // Seed popular authors first
  for (const authorData of popularAuthors) {
    const author = await findOrCreateAuthor(
      authorData.name,
      authorData.bio,
      authorData.birthDate
    );
    createdData.authors.push(author);
    console.log(`   Author: ${author.name}`);
  }
  
  // Seed random authors
  for (let i = popularAuthors.length; i < NUM_AUTHORS; i++) {
    const author = await findOrCreateAuthor(
      faker.person.fullName(),
      faker.lorem.paragraph(),
      faker.date.birthdate({ min: 1900, max: 2000, mode: 'year' })
    );
    createdData.authors.push(author);
  }

  // ======================
  // 4. SEED BOOKS
  // ======================
  console.log('\n Seeding books...');
  
  // Popular books (fixed for realism)
  const popularBooks = [
    { title: 'Laskar Pelangi', isbn: '9789793062792', year: 2005, authorIndex: 0, categoryIndex: 0 },
    { title: 'Bumi Manusia', isbn: '9789794166948', year: 1980, authorIndex: 1, categoryIndex: 5 },
    { title: 'Harry Potter dan Batu Bertuah', isbn: '9786020382958', year: 2000, authorIndex: 2, categoryIndex: 0 },
    { title: 'Supernova: Kesatria, Puteri, dan Bintang Jatuh', isbn: '9789792239844', year: 2001, authorIndex: 3, categoryIndex: 0 },
    { title: 'Cantik Itu Luka', isbn: '9789793663527', year: 2002, authorIndex: 4, categoryIndex: 4 },
  ];
  
  // Seed popular books first
  for (const bookData of popularBooks) {
    if (createdData.authors[bookData.authorIndex] && createdData.categories[bookData.categoryIndex]) {
      const book = await prisma.book.create({
        data: {
          title: bookData.title,
          isbn: bookData.isbn,
          description: faker.lorem.paragraphs({ min: 1, max: 2 }),
          year: bookData.year,
          stock: faker.number.int({ min: 5, max: 20 }),
          coverImage: '/public/uploads/default-book.jpg',
          authorId: createdData.authors[bookData.authorIndex].id,
          categoryId: createdData.categories[bookData.categoryIndex].id,
        },
      });
      createdData.books.push(book);
      console.log(`   Book: "${book.title}" by ${createdData.authors[bookData.authorIndex].name}`);
    }
  }
  
  // Seed random books
  const usedISBNs = new Set<string>(popularBooks.map(b => b.isbn));
  for (let i = popularBooks.length; i < NUM_BOOKS; i++) {
    let isbn = faker.string.numeric(13);
    while (usedISBNs.has(isbn)) isbn = faker.string.numeric(13);
    usedISBNs.add(isbn);
    
    const book = await prisma.book.create({
      data: {
        title: faker.lorem.words({ min: 1, max: 5 }),
        isbn,
        description: faker.lorem.paragraphs({ min: 1, max: 3 }),
        year: faker.number.int({ min: 1900, max: 2024 }),
        stock: faker.number.int({ min: 1, max: 20 }),
        coverImage: '/public/uploads/default-book.jpg',
        authorId: faker.helpers.arrayElement(createdData.authors).id,
        categoryId: faker.helpers.arrayElement(createdData.categories).id,
      },
    });
    createdData.books.push(book);
  }

  // ======================
  // 5. SEED TRANSACTIONS
  // ======================
  console.log('\n Seeding transactions...');
  
  // Create some active members for transactions
  const activeMembers = createdData.membersData.filter(m => m.status === 'ACTIVE');
  
  for (let i = 1; i <= NUM_TRANSACTIONS; i++) {
    const member = faker.helpers.arrayElement(activeMembers);
    const borrowDate = faker.date.past({ years: 1 });
    const dueDate = new Date(borrowDate);
    dueDate.setDate(dueDate.getDate() + 14);
    
    const status = faker.helpers.weightedArrayElement([
      { value: 'BORROWED', weight: 0.3 },
      { value: 'RETURNED', weight: 0.6 },
      { value: 'OVERDUE', weight: 0.05 },
      { value: 'CANCELLED', weight: 0.05 }
    ]);
    
    let returnDate = null;
    if (status === 'RETURNED') {
      returnDate = new Date(borrowDate);
      returnDate.setDate(returnDate.getDate() + faker.number.int({ min: 1, max: 14 }));
    }
    
    const numBooks = faker.number.int({ min: 1, max: 3 });
    const selectedBooks = faker.helpers.arrayElements(createdData.books, numBooks);
    
    const transaction = await prisma.transaction.create({
      data: {
        memberId: member.id,
        dueDate,
        returnDate,
        status: status as any,
        items: {
          create: selectedBooks.map(book => ({
            bookId: book.id,
            quantity: faker.number.int({ min: 1, max: 2 }),
          })),
        },
      },
      include: { items: true },
    });
    
    // Update book stock
    for (const item of transaction.items) {
      await prisma.book.update({
        where: { id: item.bookId },
        data: { stock: { decrement: item.quantity } },
      });
    }
    
    if (i <= 5) {
      console.log(`   Transaction ${i}: ${member.kodeMember} borrowed ${numBooks} books`);
    }
  }

  // Create some overdue transactions
  console.log('\n Creating overdue transactions...');
  const overdueMembers = activeMembers.slice(0, 3);
  for (const member of overdueMembers) {
    const borrowDate = new Date();
    borrowDate.setDate(borrowDate.getDate() - 21);
    const dueDate = new Date(borrowDate);
    dueDate.setDate(dueDate.getDate() + 14);
    const book = faker.helpers.arrayElement(createdData.books);
    
    await prisma.transaction.create({
      data: {
        memberId: member.id,
        dueDate,
        status: 'BORROWED',
        items: { create: [{ bookId: book.id, quantity: 1 }] },
      },
    });
    
    await prisma.book.update({
      where: { id: book.id },
      data: { stock: { decrement: 1 } },
    });
  }

  return createdData;
}

// ======================
// MAIN EXECUTION
// ======================
async function main() {
  try {
    const createdData = await seedData();
    
    // ======================
    // DISPLAY TESTING INFO
    // ======================
    console.log('\n' + '='.repeat(50));
    console.log(' DATABASE SEEDING COMPLETED!');
    console.log('='.repeat(50));
    
    console.log('\n TESTING CREDENTIALS:');
    console.log('='.repeat(30));
    
    console.log('\n ADMIN ACCOUNTS:');
    createdData.admins.forEach((admin, idx) => {
      console.log(`${idx + 1}. Email: ${admin.email}`);
      console.log(`   Password: ${TEST_CREDENTIALS.ADMIN.password}`);
      console.log(`   Username: ${admin.username}`);
    });
    
    console.log('\n LIBRARIAN ACCOUNTS:');
    createdData.librarians.forEach((librarian, idx) => {
      console.log(`${idx + 1}. Email: ${librarian.email}`);
      console.log(`   Password: ${TEST_CREDENTIALS.LIBRARIAN.password}`);
      console.log(`   Username: ${librarian.username}`);
    });
    
    console.log('\n MEMBER ACCOUNTS (First 5 for testing):');
    createdData.members.slice(0, 5).forEach((member, idx) => {
      console.log(`${idx + 1}. Email: ${member.email}`);
      console.log(`   Password: ${TEST_CREDENTIALS.MEMBER.password}`);
      console.log(`   Username: ${member.username}`);
    });
    
    // ======================
    // DISPLAY SUMMARY
    // ======================
    console.log('\n SEEDING SUMMARY:');
    console.log('='.repeat(30));
    console.log(` Total Users: ${createdData.users.length}`);
    console.log(`    Admin: ${createdData.admins.length}`);
    console.log(`    Librarian: ${createdData.librarians.length}`);
    console.log(`    Member: ${createdData.members.length}`);
    console.log(` Books: ${createdData.books.length}`);
    console.log(` Authors: ${createdData.authors.length}`);
    console.log(` Categories: ${createdData.categories.length}`);
    console.log(` Members: ${createdData.membersData.length}`);
    
    const transactionCount = await prisma.transaction.count();
    console.log(` Transactions: ${transactionCount}`);
    
    // ======================
    // TESTING INSTRUCTIONS
    // ======================
    console.log('\n QUICK START FOR TESTING:');
    console.log('='.repeat(30));
    console.log('\n1. Login as Admin:');
    console.log(`   curl -X POST http://localhost:3000/api/auth/login \\`);
    console.log(`     -H "Content-Type: application/json" \\`);
    console.log(`     -d '{"email": "admin1@library.com", "password": "${TEST_CREDENTIALS.ADMIN.password}"}'`);
    
    console.log('\n2. Get your token from response');
    
    console.log('\n3. Test protected endpoint:');
    console.log(`   curl -X GET http://localhost:3000/api/books/stats \\`);
    console.log(`     -H "Authorization: Bearer YOUR_TOKEN_HERE"`);
    
    console.log('\n4. Or use Swagger UI:');
    console.log(`   Open: http://localhost:3000/api-docs`);
    console.log(`   Click "Authorize" button`);
    console.log(`   Enter: Bearer YOUR_TOKEN_HERE`);
    
    // ======================
    // SAVE TO FILE
    // ======================
    const testData = {
      credentials: {
        admin: createdData.admins.map(a => ({
          email: a.email,
          password: TEST_CREDENTIALS.ADMIN.password,
          username: a.username
        })),
        librarian: createdData.librarians.map(l => ({
          email: l.email,
          password: TEST_CREDENTIALS.LIBRARIAN.password,
          username: l.username
        })),
        member: createdData.members.slice(0, 5).map(m => ({
          email: m.email,
          password: TEST_CREDENTIALS.MEMBER.password,
          username: m.username
        }))
      },
      stats: {
        users: createdData.users.length,
        books: createdData.books.length,
        authors: createdData.authors.length,
        categories: createdData.categories.length,
        members: createdData.membersData.length,
        transactions: transactionCount
      },
      sampleBooks: createdData.books.slice(0, 3).map(b => ({
        title: b.title,
        isbn: b.isbn,
        year: b.year,
        stock: b.stock
      }))
    };
    
    const filePath = path.join(__dirname, 'test-accounts.json');
    fs.writeFileSync(filePath, JSON.stringify(testData, null, 2));
    console.log(`\n Test data saved to: ${filePath}`);
    
    console.log('\n' + '='.repeat(50));
    console.log(' Ready for testing! Happy coding! ');
    console.log('='.repeat(50));
    
  } catch (error) {
    console.error('\n Error seeding database:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Execute
main();

--- FILE: ./prisma/test-accounts.json ---

{
  "credentials": {
    "admin": [
      {
        "email": "admin1@library.com",
        "password": "admin123",
        "username": "admin1"
      },
      {
        "email": "admin2@library.com",
        "password": "admin123",
        "username": "admin2"
      }
    ],
    "librarian": [
      {
        "email": "librarian1@library.com",
        "password": "librarian123",
        "username": "librarian1"
      },
      {
        "email": "librarian2@library.com",
        "password": "librarian123",
        "username": "librarian2"
      },
      {
        "email": "librarian3@library.com",
        "password": "librarian123",
        "username": "librarian3"
      }
    ],
    "member": [
      {
        "email": "member1@library.com",
        "password": "member123",
        "username": "member1"
      },
      {
        "email": "member2@library.com",
        "password": "member123",
        "username": "member2"
      },
      {
        "email": "member3@library.com",
        "password": "member123",
        "username": "member3"
      },
      {
        "email": "member4@library.com",
        "password": "member123",
        "username": "member4"
      },
      {
        "email": "member5@library.com",
        "password": "member123",
        "username": "member5"
      }
    ]
  },
  "stats": {
    "users": 25,
    "books": 50,
    "authors": 15,
    "categories": 8,
    "members": 20,
    "transactions": 33
  },
  "sampleBooks": [
    {
      "title": "Laskar Pelangi",
      "isbn": "9789793062792",
      "year": 2005,
      "stock": 14
    },
    {
      "title": "Bumi Manusia",
      "isbn": "9789794166948",
      "year": 1980,
      "stock": 10
    },
    {
      "title": "Harry Potter dan Batu Bertuah",
      "isbn": "9786020382958",
      "year": 2000,
      "stock": 12
    }
  ]
}

--- FILE: ./repositories/author.repository.ts ---

import type { Author, Prisma, PrismaClient, Book } from "../generated/client";

export interface IAuthorRepository {
    list(
        skip: number,
        limit: number,
        where: Prisma.AuthorWhereInput,
        orderBy: Prisma.AuthorOrderByWithRelationInput
    ): Promise<Author[]>;
    
    countAll(where: Prisma.AuthorWhereInput): Promise<number>;
    
    findById(id: string): Promise<(Author & { books: Book[] }) | null>;
    
    findByName(name: string): Promise<Author | null>;
    
    create(data: Prisma.AuthorCreateInput): Promise<Author>;
    
    update(id: string, data: Prisma.AuthorUpdateInput): Promise<Author>;
    
    delete(id: string): Promise<Author>;

    // Statistik: Penulis dengan produktivitas buku tertinggi
    getAuthorStats(): Promise<any>;
}

export class AuthorRepository implements IAuthorRepository {
    constructor(private prisma: PrismaClient) { }

    async list(
        skip: number,
        limit: number,
        where: Prisma.AuthorWhereInput,
        orderBy: Prisma.AuthorOrderByWithRelationInput
    ): Promise<Author[]> {
        return await this.prisma.author.findMany({
            skip,
            take: limit,
            where,
            orderBy,
            include: {
                _count: {
                    select: { books: true }
                }
            }
        });
    }

    async countAll(where: Prisma.AuthorWhereInput): Promise<number> {
        return await this.prisma.author.count({ where });
    }

    async findById(id: string): Promise<(Author & { books: Book[] }) | null> {
        return await this.prisma.author.findUnique({
            where: { id },
            include: {
                books: {
                    where: { deletedAt: null },
                    include: { category: true }
                }
            }
        }) as (Author & { books: Book[] }) | null;
    }

    async findByName(name: string): Promise<Author | null> {
        return await this.prisma.author.findUnique({
            where: { name }
        });
    }

    async create(data: Prisma.AuthorCreateInput): Promise<Author> {
        return await this.prisma.author.create({ data });
    }

    async update(id: string, data: Prisma.AuthorUpdateInput): Promise<Author> {
        return await this.prisma.author.update({
            where: { id },
            data
        });
    }

    async delete(id: string): Promise<Author> {
        // Note: Skema Anda menggunakan onDelete: Cascade pada relasi Book.
        // Menghapus Author akan menghapus semua buku terkait!
        return await this.prisma.author.delete({
            where: { id }
        });
    }

    /**
     * Analytics: Mendapatkan penulis yang paling banyak memiliki koleksi buku
     */
    async getAuthorStats() {
        return await this.prisma.author.findMany({
            select: {
                name: true,
                _count: {
                    select: { books: true }
                }
            },
            orderBy: {
                books: {
                    _count: 'desc'
                }
            },
            take: 5
        });
    }
}

--- FILE: ./repositories/category.repository.ts ---

import type { Category, Prisma, PrismaClient, Book } from "../generated/client";

export interface ICategoryRepository {
    list(
        skip: number,
        take: number,
        where: Prisma.CategoryWhereInput,
        orderBy: Prisma.CategoryOrderByWithRelationInput
    ): Promise<Category[]>;
    
    countAll(where: Prisma.CategoryWhereInput): Promise<number>;
    
    findById(id: string): Promise<(Category & { books: Book[] }) | null>;
    
    create(data: Prisma.CategoryCreateInput): Promise<Category>;
    
    update(id: string, data: Prisma.CategoryUpdateInput): Promise<Category>;
    
    // Sesuai pola repo Anda, jika ingin soft delete pastikan ada deletedAt di schema
    delete(id: string): Promise<Category>;

    // Statistik: Menghitung jumlah buku di setiap kategori
    getCategoryBookStats(): Promise<(Prisma.PickEnumerable<Prisma.BookGroupByOutputType, "categoryId"[]> & {
        _count: {
            id: number;
        };
    })[]>;
}

export class CategoryRepository implements ICategoryRepository {
    constructor(private prisma: PrismaClient) { }

    async list(
        skip: number,
        take: number,
        where: Prisma.CategoryWhereInput,
        orderBy: Prisma.CategoryOrderByWithRelationInput
    ): Promise<Category[]> {
        return await this.prisma.category.findMany({
            skip,
            take,
            where,
            orderBy,
            include: {
                _count: {
                    select: { books: true }
                }
            }
        });
    }

    async countAll(where: Prisma.CategoryWhereInput): Promise<number> {
        return await this.prisma.category.count({ where });
    }

    async findById(id: string): Promise<(Category & { books: Book[] }) | null> {
        return await this.prisma.category.findUnique({
            where: { id },
            include: {
                books: {
                    where: { deletedAt: null } // Hanya buku yang belum di-soft delete
                }
            }
        }) as (Category & { books: Book[] }) | null;
    }

    async create(data: Prisma.CategoryCreateInput): Promise<Category> {
        return await this.prisma.category.create({ data });
    }

    async update(id: string, data: Prisma.CategoryUpdateInput): Promise<Category> {
        return await this.prisma.category.update({
            where: { id },
            data
        });
    }

    async delete(id: string): Promise<Category> {
        // Karena di skema Category Anda belum ada deletedAt, 
        // ini menggunakan delete permanen.
        return await this.prisma.category.delete({
            where: { id }
        });
    }

    /**
     * Implementasi Analytics:
     * Menghitung jumlah buku per kategori (Mirip fungsi di ProductRepo Anda)
     */
    async getCategoryBookStats() {
        return await this.prisma.book.groupBy({
            by: ['categoryId'],
            where: { deletedAt: null },
            _count: {
                id: true
            }
        });
    }
}

--- FILE: ./repositories/transaction.repository.ts ---

import type { Prisma, PrismaClient, Transaction, TransactionItem } from "../generated/client";

export interface ITransactionRepository {
    list(
        skip: number,
        take: number,
        where: Prisma.TransactionWhereInput,
        orderBy: Prisma.TransactionOrderByWithRelationInput
    ): Promise<Transaction[]>;
    
    countAll(where: Prisma.TransactionWhereInput): Promise<number>;

    findById(id: string): Promise<(Transaction & { items: TransactionItem[] }) | null>;
    
    create(data: Prisma.TransactionCreateInput): Promise<Transaction>;
    
    update(id: string, data: Prisma.TransactionUpdateInput): Promise<Transaction>;
    
    // Khusus Perpustakaan: Status Analytics
    getStats(): Promise<Prisma.GetTransactionAggregateType<{
        _count: { id: true };
    }>>;
}

export class TransactionRepository implements ITransactionRepository {
    constructor(private prisma: PrismaClient) { }

    async countAll(where: Prisma.TransactionWhereInput): Promise<number> {
        return await this.prisma.transaction.count({ 
            where
        });
    }

    async list(
        skip: number,
        take: number,
        where: Prisma.TransactionWhereInput,
        orderBy: Prisma.TransactionOrderByWithRelationInput
    ): Promise<Transaction[]> {
        return await this.prisma.transaction.findMany({
            skip,
            take,
            where,
            orderBy,
            include: {
                member: true, 
                _count: { select: { items: true } }
            }
        });
    }

    async findById(id: string): Promise<(Transaction & { items: TransactionItem[] }) | null> {
        return await this.prisma.transaction.findUnique({
            where: { id },
            include: {
                member: true,
                items: {
                    include: {
                        book: true 
                    }
                }
            }
        }) as (Transaction & { items: TransactionItem[] }) | null;
    }

    async create(data: Prisma.TransactionCreateInput): Promise<Transaction> {
        return await this.prisma.transaction.create({
            data,
            include: {
                items: true
            }
        });
    }

    async update(id: string, data: Prisma.TransactionUpdateInput): Promise<Transaction> {
        return await this.prisma.transaction.update({
            where: { id },
            data,
            include: {
                items: true
            }
        });
    }

    async softDelete(id: string): Promise<Transaction> {
        return await this.prisma.transaction.update({
            where: { id },
            data: {
                status: 'CANCELLED'
            }
        });
    }

    async getStats() {
        return await this.prisma.transaction.aggregate({
            _count: { id: true },
        });
    }
}

--- FILE: ./repositories/book.repository.ts ---

import type { Prisma, PrismaClient, Book } from "../generated/client";

export interface IBookRepository {
    list(
        skip: number,
        take: number,
        where: Prisma.BookWhereInput,
        orderBy: Prisma.BookOrderByWithRelationInput
    ): Promise<Book[]>;
    countAll(where: Prisma.BookWhereInput): Promise<number>;
    findById(id: string): Promise<Book | null>;
    create(data: Prisma.BookCreateInput): Promise<Book>;
    update(id: string, data: Prisma.BookUpdateInput): Promise<Book>;
    softDelete(id: string): Promise<Book>;
    
    // Method khusus untuk Analytics Tugas
    getAdminStats(): Promise<{
        totalAvailableBooks: number;
        activeTransactions: number;
        popularBook: any;
    }>;
}

export class BookRepository implements IBookRepository {
    constructor(private prisma: PrismaClient) { }

    async list(
        skip: number,
        take: number,
        where: Prisma.BookWhereInput,
        orderBy: Prisma.BookOrderByWithRelationInput
    ): Promise<Book[]> {
        return await this.prisma.book.findMany({
            skip,
            take,
            where: {
                ...where,
                deletedAt: null // Selalu filter yang belum dihapus
            },
            orderBy,
            include: { 
                category: true,
                author: true 
            }
        });
    }

    async countAll(where: Prisma.BookWhereInput): Promise<number> {
        return await this.prisma.book.count({ 
            where: { ...where, deletedAt: null } 
        });
    }

    async findById(id: string): Promise<Book | null> {
        return await this.prisma.book.findUnique({
            where: { id, deletedAt: null },
            include: { category: true, author: true }
        });
    }

    async create(data: Prisma.BookCreateInput): Promise<Book> {
        return await this.prisma.book.create({ data });
    }

    async update(id: string, data: Prisma.BookUpdateInput): Promise<Book> {
        return await this.prisma.book.update({
            where: { id },
            data
        });
    }

    async softDelete(id: string): Promise<Book> {
        return await this.prisma.book.update({
            where: { id },
            data: { deletedAt: new Date() }
        });
    }

    /**
     * Implementasi GET /admin/stats
     */
    async getAdminStats() {
        // 1. Total buku yang tersedia (Sum dari kolom stock)
        const totalStock = await this.prisma.book.aggregate({
            _sum: { stock: true },
            where: { deletedAt: null }
        });

        // 2. Total transaksi peminjaman aktif (Status BORROWED)
        const activeTransactions = await this.prisma.transaction.count({
            where: { status: 'BORROWED' }
        });

        // 3. Buku paling populer (Paling banyak muncul di TransactionItem)
       const popularBooks = await this.prisma.transactionItem.groupBy({
          by: ['bookId'],
          _count: { bookId: true },
          orderBy: {
              _count: { bookId: 'desc' }
          },
          take: 1
      });

      let popularBookTitle = "N/A";

      // Pastikan popularBooks ada isinya sebelum mengambil ID
      const topRecord = popularBooks[0]; 
      
      if (topRecord?.bookId) {
          const book = await this.prisma.book.findUnique({
              where: { id: topRecord.bookId },
              select: { title: true }
          });
          if (book) popularBookTitle = book.title;
      }

      return {
          totalAvailableBooks: totalStock._sum.stock || 0,
          activeTransactions: activeTransactions,
          popularBook: popularBookTitle
      };
    }
}

--- FILE: ./repositories/member.repository.ts ---

import type { Member, Prisma, PrismaClient, User } from "../generated/client";

export interface IMemberRepository {
    list(
        skip: number,
        take: number,
        where: Prisma.MemberWhereInput,
        orderBy: Prisma.MemberOrderByWithRelationInput
    ): Promise<Member[]>;
    countAll(where: Prisma.MemberWhereInput): Promise<number>;
    findById(id: string): Promise<User | null & Member | null>;
    findByUserId(userId: string): Promise<Member | null>;
    findByKodeMember(kodeMember: string): Promise<Member | null>;
    create(data: Prisma.MemberCreateInput): Promise<Member>;
    update(id: string, data: Prisma.MemberUpdateInput): Promise<Member>;
    // Karena di skema Member belum ada deletedAt, kita akan simulasi atau 
    // Anda bisa menambahkannya nanti di Prisma schema.
    softDelete(id: string): Promise<Member>;
    
    // Statistik berdasarkan status member (ACTIVE, INACTIVE, SUSPENDED)
    getStatusStats(): Promise<(Prisma.PickEnumerable<Prisma.MemberGroupByOutputType, "status"[]> & {
        _count: {
            id: number;
        };
    })[]>;
}

export class MemberRepository implements IMemberRepository {
    constructor(private prisma: PrismaClient) { }

    async list(
        skip: number,
        take: number,
        where: Prisma.MemberWhereInput,
        orderBy: Prisma.MemberOrderByWithRelationInput
    ): Promise<Member[]> {
        return await this.prisma.member.findMany({
            skip,
            take,
            where: {
                ...where,
                // Catatan: Pastikan menambahkan deletedAt di schema Member jika ingin menggunakan ini
                // deletedAt: null 
            },
            orderBy,
            include: { user: true }
        });
    }

    async countAll(where: Prisma.MemberWhereInput): Promise<number> {
        return await this.prisma.member.count({
            where: {
                ...where,
                // deletedAt: null
            }
        });
    }

    async findById(id: string): Promise<User | null & Member | null> {
        return await this.prisma.member.findUnique({
            where: {
                id,
                // deletedAt: null,
            },
            include: {
                user: true
            }
        }) as any;
    }

    async findByUserId(userId: string): Promise<Member | null> {
        return await this.prisma.member.findFirst({
            where: { 
                userId: userId,
                // deletedAt: null 
            }
        });
    }

    async findByKodeMember(kodeMember: string): Promise<Member | null> {
        return await this.prisma.member.findUnique({
            where: { kodeMember }
        });
    }

    async create(data: Prisma.MemberCreateInput): Promise<Member> {
        return await this.prisma.member.create({ data });
    }

    async update(id: string, data: Prisma.MemberUpdateInput): Promise<Member> {
        return await this.prisma.member.update({
            where: { id },
            data
        });
    }

    async softDelete(id: string): Promise<Member> {
        // Jika belum ada deletedAt di Prisma, Anda bisa mengubah status menjadi INACTIVE
        return await this.prisma.member.update({
            where: { id },
            data: {
                status: 'INACTIVE'
                // deletedAt: new Date() // Gunakan ini jika sudah ada di schema
            }
        });
    }

    async getStatusStats() {
        return await this.prisma.member.groupBy({
            by: ['status'],
            // where: { deletedAt: null },
            _count: { id: true }
        });
    }
}

--- FILE: ./repositories/user.repository.ts ---

    import type { User, Prisma, PrismaClient, Member } from "../generated/client";

    export interface IUserRepository {
        // Auth related
        findByEmail(email: string): Promise<User | null>;
        findByUsername(username: string): Promise<User | null>;
        
        // CRUD
        list(
            skip: number,
            take: number,
            where: Prisma.UserWhereInput,
            orderBy: Prisma.UserOrderByWithRelationInput
        ): Promise<User[]>;
        countAll(where: Prisma.UserWhereInput): Promise<number>;
        findById(id: string): Promise<(User & { member: Member[] }) | null>;
        create(data: Prisma.UserCreateInput): Promise<User>;
        update(id: string, data: Prisma.UserUpdateInput): Promise<User>;
        delete(id: string): Promise<User>;
    }

    export class UserRepository implements IUserRepository {
        constructor(private prisma: PrismaClient) { }

        async findByEmail(email: string): Promise<User | null> {
            return await this.prisma.user.findUnique({
                where: { email }
            });
        }

        async findByUsername(username: string): Promise<User | null> {
            return await this.prisma.user.findUnique({
                where: { username }
            });
        }

        async list(
            skip: number,
            take: number,
            where: Prisma.UserWhereInput,
            orderBy: Prisma.UserOrderByWithRelationInput
        ): Promise<User[]> {
            return await this.prisma.user.findMany({
                skip,
                take,
                where,
                orderBy,
                include: {
                    member: true // Melihat data profil member terkait
                }
            });
        }

        async countAll(where: Prisma.UserWhereInput): Promise<number> {
            return await this.prisma.user.count({ where });
        }

        async findById(id: string): Promise<(User & { member: Member[] }) | null> {
            return await this.prisma.user.findUnique({
                where: { id },
                include: {
                    member: true
                }
            }) as (User & { member: Member[] }) | null;
        }

        async create(data: Prisma.UserCreateInput): Promise<User> {
            return await this.prisma.user.create({ 
                data 
            });
        }

        async update(id: string, data: Prisma.UserUpdateInput): Promise<User> {
            return await this.prisma.user.update({
                where: { id },
                data
            });
        }

        async delete(id: string): Promise<User> {
            return await this.prisma.user.delete({
                where: { id }
            });
        }
    }

--- FILE: ./prisma.ts ---

import { PrismaClient } from "./generated/client";
import { Pool } from "pg";
import { PrismaPg } from "../node_modules/@prisma/adapter-pg/dist/index";
import config from './utils/env';

let prisma : PrismaClient

export const getPrisma = () => {
    if (!prisma) {
        const pool = new Pool({ connectionString: config.DATABASE_URL })
        const adapter = new PrismaPg(pool)
        prisma = new PrismaClient({ adapter })
    }
    return prisma
}

export const prismaInstance = getPrisma()
export default prismaInstance

--- FILE: ./app.ts ---

import express, { type Application, type NextFunction, type Request, type Response } from 'express';
import morgan from 'morgan';
import helmet from 'helmet';
import cors from 'cors';
import path from 'path';
import swaggerUi from 'swagger-ui-express'; // Import ini
import swaggerSpec from './utils/swagger'; // Import ini (sesuaikan path jika perlu)

import { successResponse } from './utils/response';
import bookRouter from './routes/book.route';
import authorRouter from './routes/author.route';
import transactionRouter from './routes/transaction.route';
import memberRouter from './routes/member.route';
import authRouter from './routes/auth.route';
import categoryRouter from './routes/category.route';
import { errorHandler } from './middlewares/error.handler';

const app: Application = express();

app.use(helmet());
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());

// 1. REGISTRASI SWAGGER UI (Taruh di sini agar bisa diakses publik)
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

app.use('/uploads', express.static(path.join(__dirname, '..', 'public', 'uploads')));

// Timing middleware
app.use((req: Request, _res: Response, next: NextFunction) => {
    console.log(`Request masuk: ${req.method} ${req.path}`);
    req.startTime = Date.now();
    next();
});

// Public routes
app.get('/', (_req: Request, res: Response) => {
    successResponse(res, "Selamat datang di API Perpustakaan!", {
        status: "Server hidup",
        waktu: new Date().toLocaleString('id-ID'),
        docs: "/api-docs" // Tambahkan info docs di sini
    });
});


// Routes
app.use('/api/auth', authRouter);
app.use('/api/books', bookRouter);
app.use('/api/authors', authorRouter);
app.use('/api/categories', categoryRouter);
app.use('/api/members', memberRouter);
app.use('/api/transactions', transactionRouter);

// 2. 404 HANDLER (Gunakan app.use agar menangkap semua method)
app.use((req: Request, res: Response) => {
    res.status(404).json({
        success: false,
        message: `Route ${req.originalUrl} tidak ada di API Perpustakaan`
    });
});

// Error handler harus paling terakhir
app.use(errorHandler);

export default app;

--- FILE: ./src.txt ---

